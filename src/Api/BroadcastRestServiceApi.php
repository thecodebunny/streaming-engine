<?php
/**
 * BroadcastRestServiceApi
 * PHP version 5
 *
 * @category Class
 * @package  Thecodebunny\StreamingEngine
 * @author   TCB Codegen team
 * @link     https://github.com/tcb-api/tcb-codegen
 */

/**
 * Streaming Server REST API Reference
 *
 * Streaming Server REST API Reference
 *
 * OpenAPI spec version: V2.0
 * Contact: contact@thecodebunny.com
 * Generated by: https://github.com/tcb-api/tcb-codegen.git
 * TCB Codegen version: 2.4.13
 */

/**
 * NOTE: This class is auto generated by the tcb code generator program.
 * https://github.com/tcb-api/tcb-codegen
 * Do not edit the class manually.
 */

namespace Thecodebunny\StreamingEngine\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Thecodebunny\StreamingEngine\ApiException;
use Thecodebunny\StreamingEngine\Configuration;
use Thecodebunny\StreamingEngine\HeaderSelector;
use Thecodebunny\StreamingEngine\ObjectSerializer;

/**
 * BroadcastRestServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Thecodebunny\StreamingEngine
 * @author   TCB Codegen team
 * @link     https://github.com/tcb-api/tcb-codegen
 */
class BroadcastRestServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addEndpointV2
     *
     * Add a third pary rtmp end point to the stream. It supports adding after broadcast is started
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that stream will be republished. If required, please encode the URL (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function addEndpointV2($id, $rtmp_url)
    {
        list($response) = $this->addEndpointV2WithHttpInfo($id, $rtmp_url);
        return $response;
    }

    /**
     * Operation addEndpointV2WithHttpInfo
     *
     * Add a third pary rtmp end point to the stream. It supports adding after broadcast is started
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that stream will be republished. If required, please encode the URL (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function addEndpointV2WithHttpInfo($id, $rtmp_url)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addEndpointV2Request($id, $rtmp_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addEndpointV2Async
     *
     * Add a third pary rtmp end point to the stream. It supports adding after broadcast is started
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that stream will be republished. If required, please encode the URL (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addEndpointV2Async($id, $rtmp_url)
    {
        return $this->addEndpointV2AsyncWithHttpInfo($id, $rtmp_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addEndpointV2AsyncWithHttpInfo
     *
     * Add a third pary rtmp end point to the stream. It supports adding after broadcast is started
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that stream will be republished. If required, please encode the URL (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addEndpointV2AsyncWithHttpInfo($id, $rtmp_url)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addEndpointV2Request($id, $rtmp_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addEndpointV2'
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that stream will be republished. If required, please encode the URL (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addEndpointV2Request($id, $rtmp_url)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addEndpointV2'
            );
        }
        // verify the required parameter 'rtmp_url' is set
        if ($rtmp_url === null || (is_array($rtmp_url) && count($rtmp_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rtmp_url when calling addEndpointV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rtmp_url !== null) {
            $queryParams['rtmpUrl'] = ObjectSerializer::toQueryValue($rtmp_url);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addSocialEndpointJSONV2
     *
     * Add social endpoint to a stream for the specified service id.
     *
     * @param  string $id Stream id (required)
     * @param  string $endpoint_service_id the id of the service in order to have successfull operation. Social network must be authorized in advance (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function addSocialEndpointJSONV2($id, $endpoint_service_id)
    {
        list($response) = $this->addSocialEndpointJSONV2WithHttpInfo($id, $endpoint_service_id);
        return $response;
    }

    /**
     * Operation addSocialEndpointJSONV2WithHttpInfo
     *
     * Add social endpoint to a stream for the specified service id.
     *
     * @param  string $id Stream id (required)
     * @param  string $endpoint_service_id the id of the service in order to have successfull operation. Social network must be authorized in advance (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function addSocialEndpointJSONV2WithHttpInfo($id, $endpoint_service_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addSocialEndpointJSONV2Request($id, $endpoint_service_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addSocialEndpointJSONV2Async
     *
     * Add social endpoint to a stream for the specified service id.
     *
     * @param  string $id Stream id (required)
     * @param  string $endpoint_service_id the id of the service in order to have successfull operation. Social network must be authorized in advance (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSocialEndpointJSONV2Async($id, $endpoint_service_id)
    {
        return $this->addSocialEndpointJSONV2AsyncWithHttpInfo($id, $endpoint_service_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addSocialEndpointJSONV2AsyncWithHttpInfo
     *
     * Add social endpoint to a stream for the specified service id.
     *
     * @param  string $id Stream id (required)
     * @param  string $endpoint_service_id the id of the service in order to have successfull operation. Social network must be authorized in advance (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSocialEndpointJSONV2AsyncWithHttpInfo($id, $endpoint_service_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addSocialEndpointJSONV2Request($id, $endpoint_service_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addSocialEndpointJSONV2'
     *
     * @param  string $id Stream id (required)
     * @param  string $endpoint_service_id the id of the service in order to have successfull operation. Social network must be authorized in advance (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addSocialEndpointJSONV2Request($id, $endpoint_service_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addSocialEndpointJSONV2'
            );
        }
        // verify the required parameter 'endpoint_service_id' is set
        if ($endpoint_service_id === null || (is_array($endpoint_service_id) && count($endpoint_service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_service_id when calling addSocialEndpointJSONV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/social-endpoints/{endpointServiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($endpoint_service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointServiceId' . '}',
                ObjectSerializer::toPathValue($endpoint_service_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addSubTrack
     *
     * Add a subtrack to a main track (broadcast).
     *
     * @param  string $id Broadcast id (required)
     * @param  string $id2 Subtrack Stream Id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function addSubTrack($id, $id2)
    {
        list($response) = $this->addSubTrackWithHttpInfo($id, $id2);
        return $response;
    }

    /**
     * Operation addSubTrackWithHttpInfo
     *
     * Add a subtrack to a main track (broadcast).
     *
     * @param  string $id Broadcast id (required)
     * @param  string $id2 Subtrack Stream Id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function addSubTrackWithHttpInfo($id, $id2)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addSubTrackRequest($id, $id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addSubTrackAsync
     *
     * Add a subtrack to a main track (broadcast).
     *
     * @param  string $id Broadcast id (required)
     * @param  string $id2 Subtrack Stream Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSubTrackAsync($id, $id2)
    {
        return $this->addSubTrackAsyncWithHttpInfo($id, $id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addSubTrackAsyncWithHttpInfo
     *
     * Add a subtrack to a main track (broadcast).
     *
     * @param  string $id Broadcast id (required)
     * @param  string $id2 Subtrack Stream Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSubTrackAsyncWithHttpInfo($id, $id2)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->addSubTrackRequest($id, $id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addSubTrack'
     *
     * @param  string $id Broadcast id (required)
     * @param  string $id2 Subtrack Stream Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addSubTrackRequest($id, $id2)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addSubTrack'
            );
        }
        // verify the required parameter 'id2' is set
        if ($id2 === null || (is_array($id2) && count($id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id2 when calling addSubTrack'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/subtrack';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id2 !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id2);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkDeviceAuthStatusV2
     *
     * Check if device is authenticated in the social network. In authorization phase, this function may be polled periodically until it returns success.Server checks social network service for about 1 minute so that if userdoes not enter DeviceAuthParameters in a 1 minute, this function willnever return true
     *
     * @param  string $user_code Code of social media account (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function checkDeviceAuthStatusV2($user_code)
    {
        list($response) = $this->checkDeviceAuthStatusV2WithHttpInfo($user_code);
        return $response;
    }

    /**
     * Operation checkDeviceAuthStatusV2WithHttpInfo
     *
     * Check if device is authenticated in the social network. In authorization phase, this function may be polled periodically until it returns success.Server checks social network service for about 1 minute so that if userdoes not enter DeviceAuthParameters in a 1 minute, this function willnever return true
     *
     * @param  string $user_code Code of social media account (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkDeviceAuthStatusV2WithHttpInfo($user_code)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->checkDeviceAuthStatusV2Request($user_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkDeviceAuthStatusV2Async
     *
     * Check if device is authenticated in the social network. In authorization phase, this function may be polled periodically until it returns success.Server checks social network service for about 1 minute so that if userdoes not enter DeviceAuthParameters in a 1 minute, this function willnever return true
     *
     * @param  string $user_code Code of social media account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDeviceAuthStatusV2Async($user_code)
    {
        return $this->checkDeviceAuthStatusV2AsyncWithHttpInfo($user_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkDeviceAuthStatusV2AsyncWithHttpInfo
     *
     * Check if device is authenticated in the social network. In authorization phase, this function may be polled periodically until it returns success.Server checks social network service for about 1 minute so that if userdoes not enter DeviceAuthParameters in a 1 minute, this function willnever return true
     *
     * @param  string $user_code Code of social media account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDeviceAuthStatusV2AsyncWithHttpInfo($user_code)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->checkDeviceAuthStatusV2Request($user_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkDeviceAuthStatusV2'
     *
     * @param  string $user_code Code of social media account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkDeviceAuthStatusV2Request($user_code)
    {
        // verify the required parameter 'user_code' is set
        if ($user_code === null || (is_array($user_code) && count($user_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_code when calling checkDeviceAuthStatusV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-network-status/{userCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user_code !== null) {
            $resourcePath = str_replace(
                '{' . 'userCode' . '}',
                ObjectSerializer::toPathValue($user_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBroadcast
     *
     * Creates a Broadcast, IP Camera or Stream Source and returns the full broadcast object with rtmp address and other information. The different between Broadcast and IP Camera or Stream Source is that Broadcast is ingested by Streaming ServerIP Camera or Stream Source is pulled by Streaming Server
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object only related information should be set, it may be null as well. (optional)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs. (optional)
     * @param  bool $auto_start Only effective if stream is IP Camera or Stream Source. If it&#39;s true, it starts automatically pulling stream. Default value is false by default (optional, default to false)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Broadcast
     */
    public function createBroadcast($body = null, $social_networks = null, $auto_start = 'false')
    {
        list($response) = $this->createBroadcastWithHttpInfo($body, $social_networks, $auto_start);
        return $response;
    }

    /**
     * Operation createBroadcastWithHttpInfo
     *
     * Creates a Broadcast, IP Camera or Stream Source and returns the full broadcast object with rtmp address and other information. The different between Broadcast and IP Camera or Stream Source is that Broadcast is ingested by Streaming ServerIP Camera or Stream Source is pulled by Streaming Server
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object only related information should be set, it may be null as well. (optional)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs. (optional)
     * @param  bool $auto_start Only effective if stream is IP Camera or Stream Source. If it&#39;s true, it starts automatically pulling stream. Default value is false by default (optional, default to false)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Broadcast, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBroadcastWithHttpInfo($body = null, $social_networks = null, $auto_start = 'false')
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast';
        $request = $this->createBroadcastRequest($body, $social_networks, $auto_start);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Broadcast',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBroadcastAsync
     *
     * Creates a Broadcast, IP Camera or Stream Source and returns the full broadcast object with rtmp address and other information. The different between Broadcast and IP Camera or Stream Source is that Broadcast is ingested by Streaming ServerIP Camera or Stream Source is pulled by Streaming Server
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object only related information should be set, it may be null as well. (optional)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs. (optional)
     * @param  bool $auto_start Only effective if stream is IP Camera or Stream Source. If it&#39;s true, it starts automatically pulling stream. Default value is false by default (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBroadcastAsync($body = null, $social_networks = null, $auto_start = 'false')
    {
        return $this->createBroadcastAsyncWithHttpInfo($body, $social_networks, $auto_start)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBroadcastAsyncWithHttpInfo
     *
     * Creates a Broadcast, IP Camera or Stream Source and returns the full broadcast object with rtmp address and other information. The different between Broadcast and IP Camera or Stream Source is that Broadcast is ingested by Streaming ServerIP Camera or Stream Source is pulled by Streaming Server
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object only related information should be set, it may be null as well. (optional)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs. (optional)
     * @param  bool $auto_start Only effective if stream is IP Camera or Stream Source. If it&#39;s true, it starts automatically pulling stream. Default value is false by default (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBroadcastAsyncWithHttpInfo($body = null, $social_networks = null, $auto_start = 'false')
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast';
        $request = $this->createBroadcastRequest($body, $social_networks, $auto_start);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBroadcast'
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object only related information should be set, it may be null as well. (optional)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs. (optional)
     * @param  bool $auto_start Only effective if stream is IP Camera or Stream Source. If it&#39;s true, it starts automatically pulling stream. Default value is false by default (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createBroadcastRequest($body = null, $social_networks = null, $auto_start = 'false')
    {

        $resourcePath = '/v2/broadcasts/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($social_networks !== null) {
            $queryParams['socialNetworks'] = ObjectSerializer::toQueryValue($social_networks);
        }
        // query params
        if ($auto_start !== null) {
            $queryParams['autoStart'] = ObjectSerializer::toQueryValue($auto_start);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConferenceRoomV2
     *
     * Creates a conference room with the parameters. The room name is key so if this is called with the same room name then new room is overwritten to old one
     *
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\ConferenceRoom
     */
    public function createConferenceRoomV2($body)
    {
        list($response) = $this->createConferenceRoomV2WithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createConferenceRoomV2WithHttpInfo
     *
     * Creates a conference room with the parameters. The room name is key so if this is called with the same room name then new room is overwritten to old one
     *
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\ConferenceRoom, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConferenceRoomV2WithHttpInfo($body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\ConferenceRoom';
        $request = $this->createConferenceRoomV2Request($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\ConferenceRoom',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConferenceRoomV2Async
     *
     * Creates a conference room with the parameters. The room name is key so if this is called with the same room name then new room is overwritten to old one
     *
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConferenceRoomV2Async($body)
    {
        return $this->createConferenceRoomV2AsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConferenceRoomV2AsyncWithHttpInfo
     *
     * Creates a conference room with the parameters. The room name is key so if this is called with the same room name then new room is overwritten to old one
     *
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConferenceRoomV2AsyncWithHttpInfo($body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\ConferenceRoom';
        $request = $this->createConferenceRoomV2Request($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConferenceRoomV2'
     *
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConferenceRoomV2Request($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createConferenceRoomV2'
            );
        }

        $resourcePath = '/v2/broadcasts/conference-rooms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBroadcast
     *
     * Delete broadcast from data store and stop if it's broadcasting
     *
     * @param  string $id Id of the braodcast (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function deleteBroadcast($id)
    {
        list($response) = $this->deleteBroadcastWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteBroadcastWithHttpInfo
     *
     * Delete broadcast from data store and stop if it's broadcasting
     *
     * @param  string $id Id of the braodcast (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBroadcastWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->deleteBroadcastRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBroadcastAsync
     *
     * Delete broadcast from data store and stop if it's broadcasting
     *
     * @param  string $id Id of the braodcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBroadcastAsync($id)
    {
        return $this->deleteBroadcastAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBroadcastAsyncWithHttpInfo
     *
     * Delete broadcast from data store and stop if it's broadcasting
     *
     * @param  string $id Id of the braodcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBroadcastAsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->deleteBroadcastRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBroadcast'
     *
     * @param  string $id Id of the braodcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBroadcastRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteBroadcast'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConferenceRoomV2
     *
     * Deletes a conference room. The room id is key so if this is called with the same room id then new room is overwritten to old one
     *
     * @param  string $room_id the id of the conference room (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function deleteConferenceRoomV2($room_id)
    {
        list($response) = $this->deleteConferenceRoomV2WithHttpInfo($room_id);
        return $response;
    }

    /**
     * Operation deleteConferenceRoomV2WithHttpInfo
     *
     * Deletes a conference room. The room id is key so if this is called with the same room id then new room is overwritten to old one
     *
     * @param  string $room_id the id of the conference room (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConferenceRoomV2WithHttpInfo($room_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->deleteConferenceRoomV2Request($room_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConferenceRoomV2Async
     *
     * Deletes a conference room. The room id is key so if this is called with the same room id then new room is overwritten to old one
     *
     * @param  string $room_id the id of the conference room (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConferenceRoomV2Async($room_id)
    {
        return $this->deleteConferenceRoomV2AsyncWithHttpInfo($room_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConferenceRoomV2AsyncWithHttpInfo
     *
     * Deletes a conference room. The room id is key so if this is called with the same room id then new room is overwritten to old one
     *
     * @param  string $room_id the id of the conference room (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConferenceRoomV2AsyncWithHttpInfo($room_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->deleteConferenceRoomV2Request($room_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConferenceRoomV2'
     *
     * @param  string $room_id the id of the conference room (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteConferenceRoomV2Request($room_id)
    {
        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling deleteConferenceRoomV2'
            );
        }

        $resourcePath = '/v2/broadcasts/conference-rooms/{room_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'room_id' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editConferenceRoom
     *
     * Edits previously saved conference room
     *
     * @param  string $room_id Room id (required)
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\ConferenceRoom
     */
    public function editConferenceRoom($room_id, $body)
    {
        list($response) = $this->editConferenceRoomWithHttpInfo($room_id, $body);
        return $response;
    }

    /**
     * Operation editConferenceRoomWithHttpInfo
     *
     * Edits previously saved conference room
     *
     * @param  string $room_id Room id (required)
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\ConferenceRoom, HTTP status code, HTTP response headers (array of strings)
     */
    public function editConferenceRoomWithHttpInfo($room_id, $body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\ConferenceRoom';
        $request = $this->editConferenceRoomRequest($room_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\ConferenceRoom',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editConferenceRoomAsync
     *
     * Edits previously saved conference room
     *
     * @param  string $room_id Room id (required)
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConferenceRoomAsync($room_id, $body)
    {
        return $this->editConferenceRoomAsyncWithHttpInfo($room_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editConferenceRoomAsyncWithHttpInfo
     *
     * Edits previously saved conference room
     *
     * @param  string $room_id Room id (required)
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editConferenceRoomAsyncWithHttpInfo($room_id, $body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\ConferenceRoom';
        $request = $this->editConferenceRoomRequest($room_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editConferenceRoom'
     *
     * @param  string $room_id Room id (required)
     * @param  \Thecodebunny\StreamingEngine\Model\ConferenceRoom $body Conference Room object with start and end date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editConferenceRoomRequest($room_id, $body)
    {
        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling editConferenceRoom'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling editConferenceRoom'
            );
        }

        $resourcePath = '/v2/broadcasts/conference-rooms/{room_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'room_id' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableMp4Muxing
     *
     * Set stream specific recording setting, this setting overrides general Mp4 Muxing Setting
     *
     * @param  string $id the id of the stream (required)
     * @param  bool $recording_status Change recording status. If true, starts recording. If false stop recording (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function enableMp4Muxing($id, $recording_status)
    {
        list($response) = $this->enableMp4MuxingWithHttpInfo($id, $recording_status);
        return $response;
    }

    /**
     * Operation enableMp4MuxingWithHttpInfo
     *
     * Set stream specific recording setting, this setting overrides general Mp4 Muxing Setting
     *
     * @param  string $id the id of the stream (required)
     * @param  bool $recording_status Change recording status. If true, starts recording. If false stop recording (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableMp4MuxingWithHttpInfo($id, $recording_status)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->enableMp4MuxingRequest($id, $recording_status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enableMp4MuxingAsync
     *
     * Set stream specific recording setting, this setting overrides general Mp4 Muxing Setting
     *
     * @param  string $id the id of the stream (required)
     * @param  bool $recording_status Change recording status. If true, starts recording. If false stop recording (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableMp4MuxingAsync($id, $recording_status)
    {
        return $this->enableMp4MuxingAsyncWithHttpInfo($id, $recording_status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableMp4MuxingAsyncWithHttpInfo
     *
     * Set stream specific recording setting, this setting overrides general Mp4 Muxing Setting
     *
     * @param  string $id the id of the stream (required)
     * @param  bool $recording_status Change recording status. If true, starts recording. If false stop recording (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableMp4MuxingAsyncWithHttpInfo($id, $recording_status)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->enableMp4MuxingRequest($id, $recording_status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableMp4Muxing'
     *
     * @param  string $id the id of the stream (required)
     * @param  bool $recording_status Change recording status. If true, starts recording. If false stop recording (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function enableMp4MuxingRequest($id, $recording_status)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling enableMp4Muxing'
            );
        }
        // verify the required parameter 'recording_status' is set
        if ($recording_status === null || (is_array($recording_status) && count($recording_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_status when calling enableMp4Muxing'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/recording/{recording-status}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($recording_status !== null) {
            $resourcePath = str_replace(
                '{' . 'recording-status' . '}',
                ObjectSerializer::toPathValue($recording_status),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filterBroadcastListV2
     *
     * Returns filtered broadcast list according to type. It's useful for getting IP Camera and Stream Sources from the whole list
     *
     * @param  int $offset starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     * @param  string $type type of the stream. Possible values are \&quot;liveStream\&quot;, \&quot;ipCamera\&quot;, \&quot;streamSource\&quot;, \&quot;VoD\&quot; (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Broadcast[]
     */
    public function filterBroadcastListV2($offset, $size, $type)
    {
        list($response) = $this->filterBroadcastListV2WithHttpInfo($offset, $size, $type);
        return $response;
    }

    /**
     * Operation filterBroadcastListV2WithHttpInfo
     *
     * Returns filtered broadcast list according to type. It's useful for getting IP Camera and Stream Sources from the whole list
     *
     * @param  int $offset starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     * @param  string $type type of the stream. Possible values are \&quot;liveStream\&quot;, \&quot;ipCamera\&quot;, \&quot;streamSource\&quot;, \&quot;VoD\&quot; (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Broadcast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function filterBroadcastListV2WithHttpInfo($offset, $size, $type)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast[]';
        $request = $this->filterBroadcastListV2Request($offset, $size, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Broadcast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filterBroadcastListV2Async
     *
     * Returns filtered broadcast list according to type. It's useful for getting IP Camera and Stream Sources from the whole list
     *
     * @param  int $offset starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     * @param  string $type type of the stream. Possible values are \&quot;liveStream\&quot;, \&quot;ipCamera\&quot;, \&quot;streamSource\&quot;, \&quot;VoD\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterBroadcastListV2Async($offset, $size, $type)
    {
        return $this->filterBroadcastListV2AsyncWithHttpInfo($offset, $size, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filterBroadcastListV2AsyncWithHttpInfo
     *
     * Returns filtered broadcast list according to type. It's useful for getting IP Camera and Stream Sources from the whole list
     *
     * @param  int $offset starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     * @param  string $type type of the stream. Possible values are \&quot;liveStream\&quot;, \&quot;ipCamera\&quot;, \&quot;streamSource\&quot;, \&quot;VoD\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterBroadcastListV2AsyncWithHttpInfo($offset, $size, $type)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast[]';
        $request = $this->filterBroadcastListV2Request($offset, $size, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filterBroadcastListV2'
     *
     * @param  int $offset starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     * @param  string $type type of the stream. Possible values are \&quot;liveStream\&quot;, \&quot;ipCamera\&quot;, \&quot;streamSource\&quot;, \&quot;VoD\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filterBroadcastListV2Request($offset, $size, $type)
    {
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling filterBroadcastListV2'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling filterBroadcastListV2'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling filterBroadcastListV2'
            );
        }

        $resourcePath = '/v2/broadcasts/filter-list/{offset}/{size}/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAppLiveStatistics
     *
     * Return the active live streams
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\SimpleStat
     */
    public function getAppLiveStatistics()
    {
        list($response) = $this->getAppLiveStatisticsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAppLiveStatisticsWithHttpInfo
     *
     * Return the active live streams
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\SimpleStat, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAppLiveStatisticsWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SimpleStat';
        $request = $this->getAppLiveStatisticsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\SimpleStat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAppLiveStatisticsAsync
     *
     * Return the active live streams
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppLiveStatisticsAsync()
    {
        return $this->getAppLiveStatisticsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAppLiveStatisticsAsyncWithHttpInfo
     *
     * Return the active live streams
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppLiveStatisticsAsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SimpleStat';
        $request = $this->getAppLiveStatisticsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAppLiveStatistics'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAppLiveStatisticsRequest()
    {

        $resourcePath = '/v2/broadcasts/active-live-stream-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBroadcast
     *
     * Get broadcast object
     *
     * @param  string $id id of the broadcast (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBroadcast($id)
    {
        $this->getBroadcastWithHttpInfo($id);
    }

    /**
     * Operation getBroadcastWithHttpInfo
     *
     * Get broadcast object
     *
     * @param  string $id id of the broadcast (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBroadcastWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->getBroadcastRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getBroadcastAsync
     *
     * Get broadcast object
     *
     * @param  string $id id of the broadcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastAsync($id)
    {
        return $this->getBroadcastAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBroadcastAsyncWithHttpInfo
     *
     * Get broadcast object
     *
     * @param  string $id id of the broadcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->getBroadcastRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBroadcast'
     *
     * @param  string $id id of the broadcast (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBroadcastRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBroadcast'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBroadcastList
     *
     * Gets the broadcast list from database
     *
     * @param  int $offset This is the offset of the list, it is useful for pagination (required)
     * @param  int $size Number of items that will be fetched. If there is not enough item in the datastore, returned list size may less then this value (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Broadcast[]
     */
    public function getBroadcastList($offset, $size)
    {
        list($response) = $this->getBroadcastListWithHttpInfo($offset, $size);
        return $response;
    }

    /**
     * Operation getBroadcastListWithHttpInfo
     *
     * Gets the broadcast list from database
     *
     * @param  int $offset This is the offset of the list, it is useful for pagination (required)
     * @param  int $size Number of items that will be fetched. If there is not enough item in the datastore, returned list size may less then this value (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Broadcast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBroadcastListWithHttpInfo($offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast[]';
        $request = $this->getBroadcastListRequest($offset, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Broadcast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBroadcastListAsync
     *
     * Gets the broadcast list from database
     *
     * @param  int $offset This is the offset of the list, it is useful for pagination (required)
     * @param  int $size Number of items that will be fetched. If there is not enough item in the datastore, returned list size may less then this value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastListAsync($offset, $size)
    {
        return $this->getBroadcastListAsyncWithHttpInfo($offset, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBroadcastListAsyncWithHttpInfo
     *
     * Gets the broadcast list from database
     *
     * @param  int $offset This is the offset of the list, it is useful for pagination (required)
     * @param  int $size Number of items that will be fetched. If there is not enough item in the datastore, returned list size may less then this value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastListAsyncWithHttpInfo($offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Broadcast[]';
        $request = $this->getBroadcastListRequest($offset, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBroadcastList'
     *
     * @param  int $offset This is the offset of the list, it is useful for pagination (required)
     * @param  int $size Number of items that will be fetched. If there is not enough item in the datastore, returned list size may less then this value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBroadcastListRequest($offset, $size)
    {
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getBroadcastList'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getBroadcastList'
            );
        }

        $resourcePath = '/v2/broadcasts/list/{offset}/{size}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBroadcastStatistics
     *
     * Get the broadcast live statistics total RTMP watcher count, total HLS watcher count, total WebRTC watcher count
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\BroadcastStatistics
     */
    public function getBroadcastStatistics($id)
    {
        list($response) = $this->getBroadcastStatisticsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getBroadcastStatisticsWithHttpInfo
     *
     * Get the broadcast live statistics total RTMP watcher count, total HLS watcher count, total WebRTC watcher count
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\BroadcastStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBroadcastStatisticsWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\BroadcastStatistics';
        $request = $this->getBroadcastStatisticsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\BroadcastStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBroadcastStatisticsAsync
     *
     * Get the broadcast live statistics total RTMP watcher count, total HLS watcher count, total WebRTC watcher count
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastStatisticsAsync($id)
    {
        return $this->getBroadcastStatisticsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBroadcastStatisticsAsyncWithHttpInfo
     *
     * Get the broadcast live statistics total RTMP watcher count, total HLS watcher count, total WebRTC watcher count
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBroadcastStatisticsAsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\BroadcastStatistics';
        $request = $this->getBroadcastStatisticsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBroadcastStatistics'
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBroadcastStatisticsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBroadcastStatistics'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/broadcast-statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCameraErrorV2
     *
     * Get IP Camera Error after connection failure. If returns true, it means there is an error. If returns false, there is no error
     *
     * @param  string $ip_addr IP Addr of the Camera. This IP may contain port number (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function getCameraErrorV2($ip_addr)
    {
        list($response) = $this->getCameraErrorV2WithHttpInfo($ip_addr);
        return $response;
    }

    /**
     * Operation getCameraErrorV2WithHttpInfo
     *
     * Get IP Camera Error after connection failure. If returns true, it means there is an error. If returns false, there is no error
     *
     * @param  string $ip_addr IP Addr of the Camera. This IP may contain port number (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCameraErrorV2WithHttpInfo($ip_addr)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getCameraErrorV2Request($ip_addr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCameraErrorV2Async
     *
     * Get IP Camera Error after connection failure. If returns true, it means there is an error. If returns false, there is no error
     *
     * @param  string $ip_addr IP Addr of the Camera. This IP may contain port number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCameraErrorV2Async($ip_addr)
    {
        return $this->getCameraErrorV2AsyncWithHttpInfo($ip_addr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCameraErrorV2AsyncWithHttpInfo
     *
     * Get IP Camera Error after connection failure. If returns true, it means there is an error. If returns false, there is no error
     *
     * @param  string $ip_addr IP Addr of the Camera. This IP may contain port number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCameraErrorV2AsyncWithHttpInfo($ip_addr)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getCameraErrorV2Request($ip_addr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCameraErrorV2'
     *
     * @param  string $ip_addr IP Addr of the Camera. This IP may contain port number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCameraErrorV2Request($ip_addr)
    {
        // verify the required parameter 'ip_addr' is set
        if ($ip_addr === null || (is_array($ip_addr) && count($ip_addr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip_addr when calling getCameraErrorV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{ipAddr}/ip-camera-error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($ip_addr !== null) {
            $resourcePath = str_replace(
                '{' . 'ipAddr' . '}',
                ObjectSerializer::toPathValue($ip_addr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDetectionListV2
     *
     * Get detected objects from the stream based on offset and size
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset starting point of the list (required)
     * @param  int $size total size of the return list (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\TensorFlowObject[]
     */
    public function getDetectionListV2($id, $offset, $size)
    {
        list($response) = $this->getDetectionListV2WithHttpInfo($id, $offset, $size);
        return $response;
    }

    /**
     * Operation getDetectionListV2WithHttpInfo
     *
     * Get detected objects from the stream based on offset and size
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset starting point of the list (required)
     * @param  int $size total size of the return list (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\TensorFlowObject[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDetectionListV2WithHttpInfo($id, $offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\TensorFlowObject[]';
        $request = $this->getDetectionListV2Request($id, $offset, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\TensorFlowObject[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDetectionListV2Async
     *
     * Get detected objects from the stream based on offset and size
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset starting point of the list (required)
     * @param  int $size total size of the return list (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetectionListV2Async($id, $offset, $size)
    {
        return $this->getDetectionListV2AsyncWithHttpInfo($id, $offset, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDetectionListV2AsyncWithHttpInfo
     *
     * Get detected objects from the stream based on offset and size
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset starting point of the list (required)
     * @param  int $size total size of the return list (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetectionListV2AsyncWithHttpInfo($id, $offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\TensorFlowObject[]';
        $request = $this->getDetectionListV2Request($id, $offset, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDetectionListV2'
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset starting point of the list (required)
     * @param  int $size total size of the return list (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDetectionListV2Request($id, $offset, $size)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDetectionListV2'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getDetectionListV2'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getDetectionListV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/detections/{offset}/{size}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceAuthParametersV2
     *
     * Get device parameters for social network authorization.
     *
     * @param  string $service_name Name of the service, like Facebook, Youtube, Periscope (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceAuthParametersV2($service_name)
    {
        list($response) = $this->getDeviceAuthParametersV2WithHttpInfo($service_name);
        return $response;
    }

    /**
     * Operation getDeviceAuthParametersV2WithHttpInfo
     *
     * Get device parameters for social network authorization.
     *
     * @param  string $service_name Name of the service, like Facebook, Youtube, Periscope (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceAuthParametersV2WithHttpInfo($service_name)
    {
        $returnType = 'object';
        $request = $this->getDeviceAuthParametersV2Request($service_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAuthParametersV2Async
     *
     * Get device parameters for social network authorization.
     *
     * @param  string $service_name Name of the service, like Facebook, Youtube, Periscope (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAuthParametersV2Async($service_name)
    {
        return $this->getDeviceAuthParametersV2AsyncWithHttpInfo($service_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAuthParametersV2AsyncWithHttpInfo
     *
     * Get device parameters for social network authorization.
     *
     * @param  string $service_name Name of the service, like Facebook, Youtube, Periscope (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAuthParametersV2AsyncWithHttpInfo($service_name)
    {
        $returnType = 'object';
        $request = $this->getDeviceAuthParametersV2Request($service_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceAuthParametersV2'
     *
     * @param  string $service_name Name of the service, like Facebook, Youtube, Periscope (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceAuthParametersV2Request($service_name)
    {
        // verify the required parameter 'service_name' is set
        if ($service_name === null || (is_array($service_name) && count($service_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_name when calling getDeviceAuthParametersV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-networks/{serviceName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($service_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serviceName' . '}',
                ObjectSerializer::toPathValue($service_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInteractionFromEndpointV2
     *
     * Return the interaction from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Interaction
     */
    public function getInteractionFromEndpointV2($endpoint_service_id, $id)
    {
        list($response) = $this->getInteractionFromEndpointV2WithHttpInfo($endpoint_service_id, $id);
        return $response;
    }

    /**
     * Operation getInteractionFromEndpointV2WithHttpInfo
     *
     * Return the interaction from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Interaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInteractionFromEndpointV2WithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Interaction';
        $request = $this->getInteractionFromEndpointV2Request($endpoint_service_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Interaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInteractionFromEndpointV2Async
     *
     * Return the interaction from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInteractionFromEndpointV2Async($endpoint_service_id, $id)
    {
        return $this->getInteractionFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInteractionFromEndpointV2AsyncWithHttpInfo
     *
     * Return the interaction from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInteractionFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Interaction';
        $request = $this->getInteractionFromEndpointV2Request($endpoint_service_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInteractionFromEndpointV2'
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInteractionFromEndpointV2Request($endpoint_service_id, $id)
    {
        // verify the required parameter 'endpoint_service_id' is set
        if ($endpoint_service_id === null || (is_array($endpoint_service_id) && count($endpoint_service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_service_id when calling getInteractionFromEndpointV2'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInteractionFromEndpointV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/social-endpoints/{endpointServiceId}/interaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointServiceId' . '}',
                ObjectSerializer::toPathValue($endpoint_service_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveCommentsCountV2
     *
     * Returns the number of live comment count from a specific video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function getLiveCommentsCountV2($endpoint_service_id, $id)
    {
        list($response) = $this->getLiveCommentsCountV2WithHttpInfo($endpoint_service_id, $id);
        return $response;
    }

    /**
     * Operation getLiveCommentsCountV2WithHttpInfo
     *
     * Returns the number of live comment count from a specific video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveCommentsCountV2WithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getLiveCommentsCountV2Request($endpoint_service_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveCommentsCountV2Async
     *
     * Returns the number of live comment count from a specific video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveCommentsCountV2Async($endpoint_service_id, $id)
    {
        return $this->getLiveCommentsCountV2AsyncWithHttpInfo($endpoint_service_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveCommentsCountV2AsyncWithHttpInfo
     *
     * Returns the number of live comment count from a specific video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveCommentsCountV2AsyncWithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getLiveCommentsCountV2Request($endpoint_service_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveCommentsCountV2'
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLiveCommentsCountV2Request($endpoint_service_id, $id)
    {
        // verify the required parameter 'endpoint_service_id' is set
        if ($endpoint_service_id === null || (is_array($endpoint_service_id) && count($endpoint_service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_service_id when calling getLiveCommentsCountV2'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLiveCommentsCountV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/social-endpoints/{endpointServiceId}/live-comments-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointServiceId' . '}',
                ObjectSerializer::toPathValue($endpoint_service_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveCommentsFromEndpointV2
     *
     * Returns live comments from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id This is the id of the endpoint service (required)
     * @param  string $id Broadcast id (required)
     * @param  int $offset this is the start offset where to start getting comment (required)
     * @param  int $batch number of items to be returned (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\LiveComment[]
     */
    public function getLiveCommentsFromEndpointV2($endpoint_service_id, $id, $offset, $batch)
    {
        list($response) = $this->getLiveCommentsFromEndpointV2WithHttpInfo($endpoint_service_id, $id, $offset, $batch);
        return $response;
    }

    /**
     * Operation getLiveCommentsFromEndpointV2WithHttpInfo
     *
     * Returns live comments from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id This is the id of the endpoint service (required)
     * @param  string $id Broadcast id (required)
     * @param  int $offset this is the start offset where to start getting comment (required)
     * @param  int $batch number of items to be returned (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\LiveComment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveCommentsFromEndpointV2WithHttpInfo($endpoint_service_id, $id, $offset, $batch)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\LiveComment[]';
        $request = $this->getLiveCommentsFromEndpointV2Request($endpoint_service_id, $id, $offset, $batch);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\LiveComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveCommentsFromEndpointV2Async
     *
     * Returns live comments from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id This is the id of the endpoint service (required)
     * @param  string $id Broadcast id (required)
     * @param  int $offset this is the start offset where to start getting comment (required)
     * @param  int $batch number of items to be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveCommentsFromEndpointV2Async($endpoint_service_id, $id, $offset, $batch)
    {
        return $this->getLiveCommentsFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id, $offset, $batch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveCommentsFromEndpointV2AsyncWithHttpInfo
     *
     * Returns live comments from a specific endpoint like Facebook, Youtube, PSCP, etc. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id This is the id of the endpoint service (required)
     * @param  string $id Broadcast id (required)
     * @param  int $offset this is the start offset where to start getting comment (required)
     * @param  int $batch number of items to be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveCommentsFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id, $offset, $batch)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\LiveComment[]';
        $request = $this->getLiveCommentsFromEndpointV2Request($endpoint_service_id, $id, $offset, $batch);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveCommentsFromEndpointV2'
     *
     * @param  string $endpoint_service_id This is the id of the endpoint service (required)
     * @param  string $id Broadcast id (required)
     * @param  int $offset this is the start offset where to start getting comment (required)
     * @param  int $batch number of items to be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLiveCommentsFromEndpointV2Request($endpoint_service_id, $id, $offset, $batch)
    {
        // verify the required parameter 'endpoint_service_id' is set
        if ($endpoint_service_id === null || (is_array($endpoint_service_id) && count($endpoint_service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_service_id when calling getLiveCommentsFromEndpointV2'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getLiveCommentsFromEndpointV2'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getLiveCommentsFromEndpointV2'
            );
        }
        // verify the required parameter 'batch' is set
        if ($batch === null || (is_array($batch) && count($batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch when calling getLiveCommentsFromEndpointV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/social-endpoints/{endpointServiceId}/live-comments/{offset}/{batch}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointServiceId' . '}',
                ObjectSerializer::toPathValue($endpoint_service_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($batch !== null) {
            $resourcePath = str_replace(
                '{' . 'batch' . '}',
                ObjectSerializer::toPathValue($batch),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getObjectDetectedTotal
     *
     * Get total number of detected objects
     *
     * @param  string $id id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function getObjectDetectedTotal($id)
    {
        list($response) = $this->getObjectDetectedTotalWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getObjectDetectedTotalWithHttpInfo
     *
     * Get total number of detected objects
     *
     * @param  string $id id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function getObjectDetectedTotalWithHttpInfo($id)
    {
        $returnType = 'int';
        $request = $this->getObjectDetectedTotalRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getObjectDetectedTotalAsync
     *
     * Get total number of detected objects
     *
     * @param  string $id id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getObjectDetectedTotalAsync($id)
    {
        return $this->getObjectDetectedTotalAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getObjectDetectedTotalAsyncWithHttpInfo
     *
     * Get total number of detected objects
     *
     * @param  string $id id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getObjectDetectedTotalAsyncWithHttpInfo($id)
    {
        $returnType = 'int';
        $request = $this->getObjectDetectedTotalRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getObjectDetectedTotal'
     *
     * @param  string $id id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getObjectDetectedTotalRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getObjectDetectedTotal'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/detections/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRTMPToWebRTCStats
     *
     * Get RTMP to WebRTC path stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\RTMPToWebRTCStats
     */
    public function getRTMPToWebRTCStats()
    {
        list($response) = $this->getRTMPToWebRTCStatsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getRTMPToWebRTCStatsWithHttpInfo
     *
     * Get RTMP to WebRTC path stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\RTMPToWebRTCStats, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRTMPToWebRTCStatsWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\RTMPToWebRTCStats';
        $request = $this->getRTMPToWebRTCStatsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\RTMPToWebRTCStats',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRTMPToWebRTCStatsAsync
     *
     * Get RTMP to WebRTC path stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRTMPToWebRTCStatsAsync()
    {
        return $this->getRTMPToWebRTCStatsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRTMPToWebRTCStatsAsyncWithHttpInfo
     *
     * Get RTMP to WebRTC path stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRTMPToWebRTCStatsAsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\RTMPToWebRTCStats';
        $request = $this->getRTMPToWebRTCStatsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRTMPToWebRTCStats'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRTMPToWebRTCStatsRequest()
    {

        $resourcePath = '/v2/broadcasts/rtmp-to-webrtc-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSocialEndpointsV2
     *
     * Get Credentials of Social Endpoints
     *
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\SocialEndpointCredentials[]
     */
    public function getSocialEndpointsV2($offset, $size)
    {
        list($response) = $this->getSocialEndpointsV2WithHttpInfo($offset, $size);
        return $response;
    }

    /**
     * Operation getSocialEndpointsV2WithHttpInfo
     *
     * Get Credentials of Social Endpoints
     *
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\SocialEndpointCredentials[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSocialEndpointsV2WithHttpInfo($offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointCredentials[]';
        $request = $this->getSocialEndpointsV2Request($offset, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\SocialEndpointCredentials[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSocialEndpointsV2Async
     *
     * Get Credentials of Social Endpoints
     *
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialEndpointsV2Async($offset, $size)
    {
        return $this->getSocialEndpointsV2AsyncWithHttpInfo($offset, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSocialEndpointsV2AsyncWithHttpInfo
     *
     * Get Credentials of Social Endpoints
     *
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialEndpointsV2AsyncWithHttpInfo($offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointCredentials[]';
        $request = $this->getSocialEndpointsV2Request($offset, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSocialEndpointsV2'
     *
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSocialEndpointsV2Request($offset, $size)
    {
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getSocialEndpointsV2'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getSocialEndpointsV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-endpoints/{offset}/{size}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSocialNetworkChannelListV2
     *
     * Returns available social network channels for the specific service
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type This is very service specific, it may be page for Facebook (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\SocialEndpointChannel[]
     */
    public function getSocialNetworkChannelListV2($endpoint_id, $type)
    {
        list($response) = $this->getSocialNetworkChannelListV2WithHttpInfo($endpoint_id, $type);
        return $response;
    }

    /**
     * Operation getSocialNetworkChannelListV2WithHttpInfo
     *
     * Returns available social network channels for the specific service
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type This is very service specific, it may be page for Facebook (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\SocialEndpointChannel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSocialNetworkChannelListV2WithHttpInfo($endpoint_id, $type)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel[]';
        $request = $this->getSocialNetworkChannelListV2Request($endpoint_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSocialNetworkChannelListV2Async
     *
     * Returns available social network channels for the specific service
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type This is very service specific, it may be page for Facebook (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialNetworkChannelListV2Async($endpoint_id, $type)
    {
        return $this->getSocialNetworkChannelListV2AsyncWithHttpInfo($endpoint_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSocialNetworkChannelListV2AsyncWithHttpInfo
     *
     * Returns available social network channels for the specific service
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type This is very service specific, it may be page for Facebook (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialNetworkChannelListV2AsyncWithHttpInfo($endpoint_id, $type)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel[]';
        $request = $this->getSocialNetworkChannelListV2Request($endpoint_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSocialNetworkChannelListV2'
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type This is very service specific, it may be page for Facebook (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSocialNetworkChannelListV2Request($endpoint_id, $type)
    {
        // verify the required parameter 'endpoint_id' is set
        if ($endpoint_id === null || (is_array($endpoint_id) && count($endpoint_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_id when calling getSocialNetworkChannelListV2'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getSocialNetworkChannelListV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-networks-channel-lists/{endpointId}/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointId' . '}',
                ObjectSerializer::toPathValue($endpoint_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSocialNetworkChannelV2
     *
     * Some social networks have different channels especially for facebook,Live stream can be published on Facebook Page or Personal account, thisservice returns the related information about that.
     *
     * @param  string $endpoint_id endpointId (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\SocialEndpointChannel
     */
    public function getSocialNetworkChannelV2($endpoint_id)
    {
        list($response) = $this->getSocialNetworkChannelV2WithHttpInfo($endpoint_id);
        return $response;
    }

    /**
     * Operation getSocialNetworkChannelV2WithHttpInfo
     *
     * Some social networks have different channels especially for facebook,Live stream can be published on Facebook Page or Personal account, thisservice returns the related information about that.
     *
     * @param  string $endpoint_id endpointId (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\SocialEndpointChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSocialNetworkChannelV2WithHttpInfo($endpoint_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel';
        $request = $this->getSocialNetworkChannelV2Request($endpoint_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSocialNetworkChannelV2Async
     *
     * Some social networks have different channels especially for facebook,Live stream can be published on Facebook Page or Personal account, thisservice returns the related information about that.
     *
     * @param  string $endpoint_id endpointId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialNetworkChannelV2Async($endpoint_id)
    {
        return $this->getSocialNetworkChannelV2AsyncWithHttpInfo($endpoint_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSocialNetworkChannelV2AsyncWithHttpInfo
     *
     * Some social networks have different channels especially for facebook,Live stream can be published on Facebook Page or Personal account, thisservice returns the related information about that.
     *
     * @param  string $endpoint_id endpointId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocialNetworkChannelV2AsyncWithHttpInfo($endpoint_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SocialEndpointChannel';
        $request = $this->getSocialNetworkChannelV2Request($endpoint_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSocialNetworkChannelV2'
     *
     * @param  string $endpoint_id endpointId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSocialNetworkChannelV2Request($endpoint_id)
    {
        // verify the required parameter 'endpoint_id' is set
        if ($endpoint_id === null || (is_array($endpoint_id) && count($endpoint_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_id when calling getSocialNetworkChannelV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-networks-channel/{endpointId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointId' . '}',
                ObjectSerializer::toPathValue($endpoint_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamInfo
     *
     * Returns the stream info(width, height, bitrates and video codec) of the stream
     *
     * @param  string $id id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\BasicStreamInfo[]
     */
    public function getStreamInfo($id)
    {
        list($response) = $this->getStreamInfoWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getStreamInfoWithHttpInfo
     *
     * Returns the stream info(width, height, bitrates and video codec) of the stream
     *
     * @param  string $id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\BasicStreamInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamInfoWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\BasicStreamInfo[]';
        $request = $this->getStreamInfoRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\BasicStreamInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamInfoAsync
     *
     * Returns the stream info(width, height, bitrates and video codec) of the stream
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamInfoAsync($id)
    {
        return $this->getStreamInfoAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamInfoAsyncWithHttpInfo
     *
     * Returns the stream info(width, height, bitrates and video codec) of the stream
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamInfoAsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\BasicStreamInfo[]';
        $request = $this->getStreamInfoRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamInfo'
     *
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamInfoRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getStreamInfo'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/stream-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTokenV2
     *
     * Generates random one-time token for specified stream
     *
     * @param  string $id The id of the stream (required)
     * @param  int $expire_date The expire time of the token. It&#39;s in unix timestamp seconds (required)
     * @param  string $type Type of the token. It may be play or publish (required)
     * @param  string $room_id Room Id that token belongs to. It&#39;s not mandatory (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Token
     */
    public function getTokenV2($id, $expire_date, $type, $room_id = null)
    {
        list($response) = $this->getTokenV2WithHttpInfo($id, $expire_date, $type, $room_id);
        return $response;
    }

    /**
     * Operation getTokenV2WithHttpInfo
     *
     * Generates random one-time token for specified stream
     *
     * @param  string $id The id of the stream (required)
     * @param  int $expire_date The expire time of the token. It&#39;s in unix timestamp seconds (required)
     * @param  string $type Type of the token. It may be play or publish (required)
     * @param  string $room_id Room Id that token belongs to. It&#39;s not mandatory (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Token, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTokenV2WithHttpInfo($id, $expire_date, $type, $room_id = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Token';
        $request = $this->getTokenV2Request($id, $expire_date, $type, $room_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Token',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTokenV2Async
     *
     * Generates random one-time token for specified stream
     *
     * @param  string $id The id of the stream (required)
     * @param  int $expire_date The expire time of the token. It&#39;s in unix timestamp seconds (required)
     * @param  string $type Type of the token. It may be play or publish (required)
     * @param  string $room_id Room Id that token belongs to. It&#39;s not mandatory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTokenV2Async($id, $expire_date, $type, $room_id = null)
    {
        return $this->getTokenV2AsyncWithHttpInfo($id, $expire_date, $type, $room_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTokenV2AsyncWithHttpInfo
     *
     * Generates random one-time token for specified stream
     *
     * @param  string $id The id of the stream (required)
     * @param  int $expire_date The expire time of the token. It&#39;s in unix timestamp seconds (required)
     * @param  string $type Type of the token. It may be play or publish (required)
     * @param  string $room_id Room Id that token belongs to. It&#39;s not mandatory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTokenV2AsyncWithHttpInfo($id, $expire_date, $type, $room_id = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Token';
        $request = $this->getTokenV2Request($id, $expire_date, $type, $room_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTokenV2'
     *
     * @param  string $id The id of the stream (required)
     * @param  int $expire_date The expire time of the token. It&#39;s in unix timestamp seconds (required)
     * @param  string $type Type of the token. It may be play or publish (required)
     * @param  string $room_id Room Id that token belongs to. It&#39;s not mandatory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTokenV2Request($id, $expire_date, $type, $room_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTokenV2'
            );
        }
        // verify the required parameter 'expire_date' is set
        if ($expire_date === null || (is_array($expire_date) && count($expire_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expire_date when calling getTokenV2'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getTokenV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($expire_date !== null) {
            $queryParams['expireDate'] = ObjectSerializer::toQueryValue($expire_date);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTotalBroadcastNumberV2
     *
     * Get the total number of broadcasts
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\SimpleStat
     */
    public function getTotalBroadcastNumberV2()
    {
        list($response) = $this->getTotalBroadcastNumberV2WithHttpInfo();
        return $response;
    }

    /**
     * Operation getTotalBroadcastNumberV2WithHttpInfo
     *
     * Get the total number of broadcasts
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\SimpleStat, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTotalBroadcastNumberV2WithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SimpleStat';
        $request = $this->getTotalBroadcastNumberV2Request();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\SimpleStat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTotalBroadcastNumberV2Async
     *
     * Get the total number of broadcasts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTotalBroadcastNumberV2Async()
    {
        return $this->getTotalBroadcastNumberV2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTotalBroadcastNumberV2AsyncWithHttpInfo
     *
     * Get the total number of broadcasts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTotalBroadcastNumberV2AsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\SimpleStat';
        $request = $this->getTotalBroadcastNumberV2Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTotalBroadcastNumberV2'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTotalBroadcastNumberV2Request()
    {

        $resourcePath = '/v2/broadcasts/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getViewerCountFromEndpointV2
     *
     * Return the number of live views in specified video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function getViewerCountFromEndpointV2($endpoint_service_id, $id)
    {
        list($response) = $this->getViewerCountFromEndpointV2WithHttpInfo($endpoint_service_id, $id);
        return $response;
    }

    /**
     * Operation getViewerCountFromEndpointV2WithHttpInfo
     *
     * Return the number of live views in specified video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function getViewerCountFromEndpointV2WithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getViewerCountFromEndpointV2Request($endpoint_service_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getViewerCountFromEndpointV2Async
     *
     * Return the number of live views in specified video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewerCountFromEndpointV2Async($endpoint_service_id, $id)
    {
        return $this->getViewerCountFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getViewerCountFromEndpointV2AsyncWithHttpInfo
     *
     * Return the number of live views in specified video service endpoint. It works If interactivity is collected which can be enabled/disabled by properties file.
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewerCountFromEndpointV2AsyncWithHttpInfo($endpoint_service_id, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->getViewerCountFromEndpointV2Request($endpoint_service_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getViewerCountFromEndpointV2'
     *
     * @param  string $endpoint_service_id the id of the endpoint (required)
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getViewerCountFromEndpointV2Request($endpoint_service_id, $id)
    {
        // verify the required parameter 'endpoint_service_id' is set
        if ($endpoint_service_id === null || (is_array($endpoint_service_id) && count($endpoint_service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_service_id when calling getViewerCountFromEndpointV2'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getViewerCountFromEndpointV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/social-endpoints/{endpointServiceId}/live-views-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointServiceId' . '}',
                ObjectSerializer::toPathValue($endpoint_service_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebRTCClientStatsListV2
     *
     * Get WebRTC Client Statistics such as : Audio bitrate, Video bitrate, Target bitrate, Video Sent Period etc.
     *
     * @param  int $offset offset of the list (required)
     * @param  int $size Number of items that will be fetched (required)
     * @param  string $stream_id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\WebRTCClientStats[]
     */
    public function getWebRTCClientStatsListV2($offset, $size, $stream_id)
    {
        list($response) = $this->getWebRTCClientStatsListV2WithHttpInfo($offset, $size, $stream_id);
        return $response;
    }

    /**
     * Operation getWebRTCClientStatsListV2WithHttpInfo
     *
     * Get WebRTC Client Statistics such as : Audio bitrate, Video bitrate, Target bitrate, Video Sent Period etc.
     *
     * @param  int $offset offset of the list (required)
     * @param  int $size Number of items that will be fetched (required)
     * @param  string $stream_id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\WebRTCClientStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebRTCClientStatsListV2WithHttpInfo($offset, $size, $stream_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCClientStats[]';
        $request = $this->getWebRTCClientStatsListV2Request($offset, $size, $stream_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\WebRTCClientStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebRTCClientStatsListV2Async
     *
     * Get WebRTC Client Statistics such as : Audio bitrate, Video bitrate, Target bitrate, Video Sent Period etc.
     *
     * @param  int $offset offset of the list (required)
     * @param  int $size Number of items that will be fetched (required)
     * @param  string $stream_id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCClientStatsListV2Async($offset, $size, $stream_id)
    {
        return $this->getWebRTCClientStatsListV2AsyncWithHttpInfo($offset, $size, $stream_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebRTCClientStatsListV2AsyncWithHttpInfo
     *
     * Get WebRTC Client Statistics such as : Audio bitrate, Video bitrate, Target bitrate, Video Sent Period etc.
     *
     * @param  int $offset offset of the list (required)
     * @param  int $size Number of items that will be fetched (required)
     * @param  string $stream_id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCClientStatsListV2AsyncWithHttpInfo($offset, $size, $stream_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCClientStats[]';
        $request = $this->getWebRTCClientStatsListV2Request($offset, $size, $stream_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebRTCClientStatsListV2'
     *
     * @param  int $offset offset of the list (required)
     * @param  int $size Number of items that will be fetched (required)
     * @param  string $stream_id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebRTCClientStatsListV2Request($offset, $size, $stream_id)
    {
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getWebRTCClientStatsListV2'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getWebRTCClientStatsListV2'
            );
        }
        // verify the required parameter 'stream_id' is set
        if ($stream_id === null || (is_array($stream_id) && count($stream_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_id when calling getWebRTCClientStatsListV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{stream_id}/webrtc-client-stats/{offset}/{size}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }
        // path params
        if ($stream_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stream_id' . '}',
                ObjectSerializer::toPathValue($stream_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebRTCLowLevelReceiveStats
     *
     * Get WebRTC Low Level receive stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\WebRTCSendStats
     */
    public function getWebRTCLowLevelReceiveStats()
    {
        list($response) = $this->getWebRTCLowLevelReceiveStatsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getWebRTCLowLevelReceiveStatsWithHttpInfo
     *
     * Get WebRTC Low Level receive stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\WebRTCSendStats, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebRTCLowLevelReceiveStatsWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats';
        $request = $this->getWebRTCLowLevelReceiveStatsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebRTCLowLevelReceiveStatsAsync
     *
     * Get WebRTC Low Level receive stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCLowLevelReceiveStatsAsync()
    {
        return $this->getWebRTCLowLevelReceiveStatsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebRTCLowLevelReceiveStatsAsyncWithHttpInfo
     *
     * Get WebRTC Low Level receive stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCLowLevelReceiveStatsAsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats';
        $request = $this->getWebRTCLowLevelReceiveStatsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebRTCLowLevelReceiveStats'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebRTCLowLevelReceiveStatsRequest()
    {

        $resourcePath = '/v2/broadcasts/webrtc-receive-low-level-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebRTCLowLevelSendStats
     *
     * Get WebRTC Low Level Send stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\WebRTCSendStats
     */
    public function getWebRTCLowLevelSendStats()
    {
        list($response) = $this->getWebRTCLowLevelSendStatsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getWebRTCLowLevelSendStatsWithHttpInfo
     *
     * Get WebRTC Low Level Send stats in general
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\WebRTCSendStats, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebRTCLowLevelSendStatsWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats';
        $request = $this->getWebRTCLowLevelSendStatsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebRTCLowLevelSendStatsAsync
     *
     * Get WebRTC Low Level Send stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCLowLevelSendStatsAsync()
    {
        return $this->getWebRTCLowLevelSendStatsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebRTCLowLevelSendStatsAsyncWithHttpInfo
     *
     * Get WebRTC Low Level Send stats in general
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebRTCLowLevelSendStatsAsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\WebRTCSendStats';
        $request = $this->getWebRTCLowLevelSendStatsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebRTCLowLevelSendStats'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebRTCLowLevelSendStatsRequest()
    {

        $resourcePath = '/v2/broadcasts/webrtc-send-low-level-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importLiveStreams2StalkerV2
     *
     * Import Live Streams to Stalker Portal
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function importLiveStreams2StalkerV2()
    {
        list($response) = $this->importLiveStreams2StalkerV2WithHttpInfo();
        return $response;
    }

    /**
     * Operation importLiveStreams2StalkerV2WithHttpInfo
     *
     * Import Live Streams to Stalker Portal
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function importLiveStreams2StalkerV2WithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->importLiveStreams2StalkerV2Request();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importLiveStreams2StalkerV2Async
     *
     * Import Live Streams to Stalker Portal
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importLiveStreams2StalkerV2Async()
    {
        return $this->importLiveStreams2StalkerV2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importLiveStreams2StalkerV2AsyncWithHttpInfo
     *
     * Import Live Streams to Stalker Portal
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importLiveStreams2StalkerV2AsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->importLiveStreams2StalkerV2Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importLiveStreams2StalkerV2'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importLiveStreams2StalkerV2Request()
    {

        $resourcePath = '/v2/broadcasts/import-to-stalker';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTokensV2
     *
     * Get the all tokens of requested stream
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Token[]
     */
    public function listTokensV2($id, $offset, $size)
    {
        list($response) = $this->listTokensV2WithHttpInfo($id, $offset, $size);
        return $response;
    }

    /**
     * Operation listTokensV2WithHttpInfo
     *
     * Get the all tokens of requested stream
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Token[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listTokensV2WithHttpInfo($id, $offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Token[]';
        $request = $this->listTokensV2Request($id, $offset, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Token[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTokensV2Async
     *
     * Get the all tokens of requested stream
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTokensV2Async($id, $offset, $size)
    {
        return $this->listTokensV2AsyncWithHttpInfo($id, $offset, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTokensV2AsyncWithHttpInfo
     *
     * Get the all tokens of requested stream
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTokensV2AsyncWithHttpInfo($id, $offset, $size)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Token[]';
        $request = $this->listTokensV2Request($id, $offset, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTokensV2'
     *
     * @param  string $id the id of the stream (required)
     * @param  int $offset the starting point of the list (required)
     * @param  int $size size of the return list (max:50 ) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTokensV2Request($id, $offset, $size)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling listTokensV2'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling listTokensV2'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling listTokensV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/tokens/list/{offset}/{size}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }
        // path params
        if ($size !== null) {
            $resourcePath = str_replace(
                '{' . 'size' . '}',
                ObjectSerializer::toPathValue($size),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveIPCamera
     *
     * Move IP Camera. It support continuous, relative and absolute move. By default it's relative move.Movement parameters should be given according to movement type. Generally here are the values For Absolute move, value X and value Y is between -1.0f and 1.0f. Zooom value is between 0.0f and 1.0fFor Relative move, value X, value Y and Zoom Value is between -1.0f and 1.0fFor Continous move,value X, value Y and Zoom Value is between -1.0f and 1.0f
     *
     * @param  string $id The id of the IP Camera (required)
     * @param  float $value_x Movement in X direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_y Movement in Y direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_z Movement in Zoom. If not specified, it&#39;s assumed to be zero. Valid ranges for relative and continous move is between -1.0f and 1.0f. For absolute move between 0.0f and 1.0f (optional)
     * @param  string $movement Movement type. It can be absolute, relative or continuous. If not specified, it&#39;s relative (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function moveIPCamera($id, $value_x = null, $value_y = null, $value_z = null, $movement = null)
    {
        list($response) = $this->moveIPCameraWithHttpInfo($id, $value_x, $value_y, $value_z, $movement);
        return $response;
    }

    /**
     * Operation moveIPCameraWithHttpInfo
     *
     * Move IP Camera. It support continuous, relative and absolute move. By default it's relative move.Movement parameters should be given according to movement type. Generally here are the values For Absolute move, value X and value Y is between -1.0f and 1.0f. Zooom value is between 0.0f and 1.0fFor Relative move, value X, value Y and Zoom Value is between -1.0f and 1.0fFor Continous move,value X, value Y and Zoom Value is between -1.0f and 1.0f
     *
     * @param  string $id The id of the IP Camera (required)
     * @param  float $value_x Movement in X direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_y Movement in Y direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_z Movement in Zoom. If not specified, it&#39;s assumed to be zero. Valid ranges for relative and continous move is between -1.0f and 1.0f. For absolute move between 0.0f and 1.0f (optional)
     * @param  string $movement Movement type. It can be absolute, relative or continuous. If not specified, it&#39;s relative (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveIPCameraWithHttpInfo($id, $value_x = null, $value_y = null, $value_z = null, $movement = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->moveIPCameraRequest($id, $value_x, $value_y, $value_z, $movement);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation moveIPCameraAsync
     *
     * Move IP Camera. It support continuous, relative and absolute move. By default it's relative move.Movement parameters should be given according to movement type. Generally here are the values For Absolute move, value X and value Y is between -1.0f and 1.0f. Zooom value is between 0.0f and 1.0fFor Relative move, value X, value Y and Zoom Value is between -1.0f and 1.0fFor Continous move,value X, value Y and Zoom Value is between -1.0f and 1.0f
     *
     * @param  string $id The id of the IP Camera (required)
     * @param  float $value_x Movement in X direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_y Movement in Y direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_z Movement in Zoom. If not specified, it&#39;s assumed to be zero. Valid ranges for relative and continous move is between -1.0f and 1.0f. For absolute move between 0.0f and 1.0f (optional)
     * @param  string $movement Movement type. It can be absolute, relative or continuous. If not specified, it&#39;s relative (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveIPCameraAsync($id, $value_x = null, $value_y = null, $value_z = null, $movement = null)
    {
        return $this->moveIPCameraAsyncWithHttpInfo($id, $value_x, $value_y, $value_z, $movement)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveIPCameraAsyncWithHttpInfo
     *
     * Move IP Camera. It support continuous, relative and absolute move. By default it's relative move.Movement parameters should be given according to movement type. Generally here are the values For Absolute move, value X and value Y is between -1.0f and 1.0f. Zooom value is between 0.0f and 1.0fFor Relative move, value X, value Y and Zoom Value is between -1.0f and 1.0fFor Continous move,value X, value Y and Zoom Value is between -1.0f and 1.0f
     *
     * @param  string $id The id of the IP Camera (required)
     * @param  float $value_x Movement in X direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_y Movement in Y direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_z Movement in Zoom. If not specified, it&#39;s assumed to be zero. Valid ranges for relative and continous move is between -1.0f and 1.0f. For absolute move between 0.0f and 1.0f (optional)
     * @param  string $movement Movement type. It can be absolute, relative or continuous. If not specified, it&#39;s relative (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveIPCameraAsyncWithHttpInfo($id, $value_x = null, $value_y = null, $value_z = null, $movement = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->moveIPCameraRequest($id, $value_x, $value_y, $value_z, $movement);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveIPCamera'
     *
     * @param  string $id The id of the IP Camera (required)
     * @param  float $value_x Movement in X direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_y Movement in Y direction. If not specified, it&#39;s assumed to be zero. Valid ranges between -1.0f and 1.0f for all movements (optional)
     * @param  float $value_z Movement in Zoom. If not specified, it&#39;s assumed to be zero. Valid ranges for relative and continous move is between -1.0f and 1.0f. For absolute move between 0.0f and 1.0f (optional)
     * @param  string $movement Movement type. It can be absolute, relative or continuous. If not specified, it&#39;s relative (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function moveIPCameraRequest($id, $value_x = null, $value_y = null, $value_z = null, $movement = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling moveIPCamera'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/ip-camera/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($value_x !== null) {
            $queryParams['valueX'] = ObjectSerializer::toQueryValue($value_x);
        }
        // query params
        if ($value_y !== null) {
            $queryParams['valueY'] = ObjectSerializer::toQueryValue($value_y);
        }
        // query params
        if ($value_z !== null) {
            $queryParams['valueZ'] = ObjectSerializer::toQueryValue($value_z);
        }
        // query params
        if ($movement !== null) {
            $queryParams['movement'] = ObjectSerializer::toQueryValue($movement);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeEndpoint
     *
     * Remove third pary rtmp end point from the stream. For the stream that is broadcasting, it will stop immediately
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that will be stopped. (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function removeEndpoint($id, $rtmp_url)
    {
        list($response) = $this->removeEndpointWithHttpInfo($id, $rtmp_url);
        return $response;
    }

    /**
     * Operation removeEndpointWithHttpInfo
     *
     * Remove third pary rtmp end point from the stream. For the stream that is broadcasting, it will stop immediately
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that will be stopped. (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeEndpointWithHttpInfo($id, $rtmp_url)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->removeEndpointRequest($id, $rtmp_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeEndpointAsync
     *
     * Remove third pary rtmp end point from the stream. For the stream that is broadcasting, it will stop immediately
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that will be stopped. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEndpointAsync($id, $rtmp_url)
    {
        return $this->removeEndpointAsyncWithHttpInfo($id, $rtmp_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeEndpointAsyncWithHttpInfo
     *
     * Remove third pary rtmp end point from the stream. For the stream that is broadcasting, it will stop immediately
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that will be stopped. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEndpointAsyncWithHttpInfo($id, $rtmp_url)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->removeEndpointRequest($id, $rtmp_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeEndpoint'
     *
     * @param  string $id Broadcast id (required)
     * @param  string $rtmp_url RTMP url of the endpoint that will be stopped. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeEndpointRequest($id, $rtmp_url)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling removeEndpoint'
            );
        }
        // verify the required parameter 'rtmp_url' is set
        if ($rtmp_url === null || (is_array($rtmp_url) && count($rtmp_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rtmp_url when calling removeEndpoint'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rtmp_url !== null) {
            $queryParams['rtmpUrl'] = ObjectSerializer::toQueryValue($rtmp_url);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revokeSocialNetworkV2
     *
     * Revoke authorization from a social network account that is authorized before
     *
     * @param  string $endpoint_id Endpoint id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function revokeSocialNetworkV2($endpoint_id)
    {
        list($response) = $this->revokeSocialNetworkV2WithHttpInfo($endpoint_id);
        return $response;
    }

    /**
     * Operation revokeSocialNetworkV2WithHttpInfo
     *
     * Revoke authorization from a social network account that is authorized before
     *
     * @param  string $endpoint_id Endpoint id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeSocialNetworkV2WithHttpInfo($endpoint_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->revokeSocialNetworkV2Request($endpoint_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation revokeSocialNetworkV2Async
     *
     * Revoke authorization from a social network account that is authorized before
     *
     * @param  string $endpoint_id Endpoint id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeSocialNetworkV2Async($endpoint_id)
    {
        return $this->revokeSocialNetworkV2AsyncWithHttpInfo($endpoint_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revokeSocialNetworkV2AsyncWithHttpInfo
     *
     * Revoke authorization from a social network account that is authorized before
     *
     * @param  string $endpoint_id Endpoint id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeSocialNetworkV2AsyncWithHttpInfo($endpoint_id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->revokeSocialNetworkV2Request($endpoint_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revokeSocialNetworkV2'
     *
     * @param  string $endpoint_id Endpoint id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function revokeSocialNetworkV2Request($endpoint_id)
    {
        // verify the required parameter 'endpoint_id' is set
        if ($endpoint_id === null || (is_array($endpoint_id) && count($endpoint_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_id when calling revokeSocialNetworkV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-networks/{endpointId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointId' . '}',
                ObjectSerializer::toPathValue($endpoint_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revokeTokensV2
     *
     * Removes all tokens related with requested stream
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function revokeTokensV2($id)
    {
        list($response) = $this->revokeTokensV2WithHttpInfo($id);
        return $response;
    }

    /**
     * Operation revokeTokensV2WithHttpInfo
     *
     * Removes all tokens related with requested stream
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeTokensV2WithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->revokeTokensV2Request($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation revokeTokensV2Async
     *
     * Removes all tokens related with requested stream
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeTokensV2Async($id)
    {
        return $this->revokeTokensV2AsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revokeTokensV2AsyncWithHttpInfo
     *
     * Removes all tokens related with requested stream
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeTokensV2AsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->revokeTokensV2Request($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revokeTokensV2'
     *
     * @param  string $id the id of the stream (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function revokeTokensV2Request($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling revokeTokensV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchOnvifDevicesV2
     *
     * Get Discovered ONVIF IP Cameras, this service perform a discovery inside of internal network and get automatically  ONVIF enabled camera information
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function searchOnvifDevicesV2()
    {
        list($response) = $this->searchOnvifDevicesV2WithHttpInfo();
        return $response;
    }

    /**
     * Operation searchOnvifDevicesV2WithHttpInfo
     *
     * Get Discovered ONVIF IP Cameras, this service perform a discovery inside of internal network and get automatically  ONVIF enabled camera information
     *
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchOnvifDevicesV2WithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->searchOnvifDevicesV2Request();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchOnvifDevicesV2Async
     *
     * Get Discovered ONVIF IP Cameras, this service perform a discovery inside of internal network and get automatically  ONVIF enabled camera information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchOnvifDevicesV2Async()
    {
        return $this->searchOnvifDevicesV2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchOnvifDevicesV2AsyncWithHttpInfo
     *
     * Get Discovered ONVIF IP Cameras, this service perform a discovery inside of internal network and get automatically  ONVIF enabled camera information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchOnvifDevicesV2AsyncWithHttpInfo()
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->searchOnvifDevicesV2Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchOnvifDevicesV2'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchOnvifDevicesV2Request()
    {

        $resourcePath = '/v2/broadcasts/onvif-devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setSocialNetworkChannelListV2
     *
     * If there are multiple channels in a social network,this method sets specific channel for that endpointIf a user has pages in Facebook, this method sets the specific page to publish live stream to
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type type (required)
     * @param  string $id id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function setSocialNetworkChannelListV2($endpoint_id, $type, $id)
    {
        list($response) = $this->setSocialNetworkChannelListV2WithHttpInfo($endpoint_id, $type, $id);
        return $response;
    }

    /**
     * Operation setSocialNetworkChannelListV2WithHttpInfo
     *
     * If there are multiple channels in a social network,this method sets specific channel for that endpointIf a user has pages in Facebook, this method sets the specific page to publish live stream to
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type type (required)
     * @param  string $id id (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function setSocialNetworkChannelListV2WithHttpInfo($endpoint_id, $type, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->setSocialNetworkChannelListV2Request($endpoint_id, $type, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setSocialNetworkChannelListV2Async
     *
     * If there are multiple channels in a social network,this method sets specific channel for that endpointIf a user has pages in Facebook, this method sets the specific page to publish live stream to
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type type (required)
     * @param  string $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setSocialNetworkChannelListV2Async($endpoint_id, $type, $id)
    {
        return $this->setSocialNetworkChannelListV2AsyncWithHttpInfo($endpoint_id, $type, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setSocialNetworkChannelListV2AsyncWithHttpInfo
     *
     * If there are multiple channels in a social network,this method sets specific channel for that endpointIf a user has pages in Facebook, this method sets the specific page to publish live stream to
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type type (required)
     * @param  string $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setSocialNetworkChannelListV2AsyncWithHttpInfo($endpoint_id, $type, $id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->setSocialNetworkChannelListV2Request($endpoint_id, $type, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setSocialNetworkChannelListV2'
     *
     * @param  string $endpoint_id endpointId (required)
     * @param  string $type type (required)
     * @param  string $id id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setSocialNetworkChannelListV2Request($endpoint_id, $type, $id)
    {
        // verify the required parameter 'endpoint_id' is set
        if ($endpoint_id === null || (is_array($endpoint_id) && count($endpoint_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint_id when calling setSocialNetworkChannelListV2'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling setSocialNetworkChannelListV2'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setSocialNetworkChannelListV2'
            );
        }

        $resourcePath = '/v2/broadcasts/social-networks-channels/{endpointId}/{type}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpoint_id !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointId' . '}',
                ObjectSerializer::toPathValue($endpoint_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startStreamSourceV2
     *
     * Start external sources (IP Cameras and Stream Sources) again if it is added and stopped before
     *
     * @param  string $id the id of the stream. The broadcast type should be IP Camera or Stream Source otherwise it does not work (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function startStreamSourceV2($id)
    {
        list($response) = $this->startStreamSourceV2WithHttpInfo($id);
        return $response;
    }

    /**
     * Operation startStreamSourceV2WithHttpInfo
     *
     * Start external sources (IP Cameras and Stream Sources) again if it is added and stopped before
     *
     * @param  string $id the id of the stream. The broadcast type should be IP Camera or Stream Source otherwise it does not work (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function startStreamSourceV2WithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->startStreamSourceV2Request($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startStreamSourceV2Async
     *
     * Start external sources (IP Cameras and Stream Sources) again if it is added and stopped before
     *
     * @param  string $id the id of the stream. The broadcast type should be IP Camera or Stream Source otherwise it does not work (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startStreamSourceV2Async($id)
    {
        return $this->startStreamSourceV2AsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startStreamSourceV2AsyncWithHttpInfo
     *
     * Start external sources (IP Cameras and Stream Sources) again if it is added and stopped before
     *
     * @param  string $id the id of the stream. The broadcast type should be IP Camera or Stream Source otherwise it does not work (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startStreamSourceV2AsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->startStreamSourceV2Request($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startStreamSourceV2'
     *
     * @param  string $id the id of the stream. The broadcast type should be IP Camera or Stream Source otherwise it does not work (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startStreamSourceV2Request($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling startStreamSourceV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopMove
     *
     * Stop move for IP Camera.
     *
     * @param  string $id the id of the IP Camera (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function stopMove($id)
    {
        list($response) = $this->stopMoveWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation stopMoveWithHttpInfo
     *
     * Stop move for IP Camera.
     *
     * @param  string $id the id of the IP Camera (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopMoveWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->stopMoveRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stopMoveAsync
     *
     * Stop move for IP Camera.
     *
     * @param  string $id the id of the IP Camera (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMoveAsync($id)
    {
        return $this->stopMoveAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopMoveAsyncWithHttpInfo
     *
     * Stop move for IP Camera.
     *
     * @param  string $id the id of the IP Camera (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMoveAsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->stopMoveRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopMove'
     *
     * @param  string $id the id of the IP Camera (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stopMoveRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stopMove'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/ip-camera/stop-move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopStreamingV2
     *
     * Stop streaming for the active stream. It both stops ingested(RTMP, WebRTC) or pulled stream sources (IP Cameras and Stream Sources)
     *
     * @param  string $id the id of the broadcast. (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function stopStreamingV2($id)
    {
        list($response) = $this->stopStreamingV2WithHttpInfo($id);
        return $response;
    }

    /**
     * Operation stopStreamingV2WithHttpInfo
     *
     * Stop streaming for the active stream. It both stops ingested(RTMP, WebRTC) or pulled stream sources (IP Cameras and Stream Sources)
     *
     * @param  string $id the id of the broadcast. (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopStreamingV2WithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->stopStreamingV2Request($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stopStreamingV2Async
     *
     * Stop streaming for the active stream. It both stops ingested(RTMP, WebRTC) or pulled stream sources (IP Cameras and Stream Sources)
     *
     * @param  string $id the id of the broadcast. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopStreamingV2Async($id)
    {
        return $this->stopStreamingV2AsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopStreamingV2AsyncWithHttpInfo
     *
     * Stop streaming for the active stream. It both stops ingested(RTMP, WebRTC) or pulled stream sources (IP Cameras and Stream Sources)
     *
     * @param  string $id the id of the broadcast. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopStreamingV2AsyncWithHttpInfo($id)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->stopStreamingV2Request($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopStreamingV2'
     *
     * @param  string $id the id of the broadcast. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stopStreamingV2Request($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stopStreamingV2'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}/stop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBroadcast
     *
     * Updates the Broadcast objects fields if it's not null. The updated fields are as follows: name, description, userName, password, IP address, streamUrl of the broadcast. It also updates the social endpoints
     *
     * @param  string $id Broadcast id (required)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs (required)
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object with the updates (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function updateBroadcast($id, $social_networks, $body = null)
    {
        list($response) = $this->updateBroadcastWithHttpInfo($id, $social_networks, $body);
        return $response;
    }

    /**
     * Operation updateBroadcastWithHttpInfo
     *
     * Updates the Broadcast objects fields if it's not null. The updated fields are as follows: name, description, userName, password, IP address, streamUrl of the broadcast. It also updates the social endpoints
     *
     * @param  string $id Broadcast id (required)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs (required)
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object with the updates (optional)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBroadcastWithHttpInfo($id, $social_networks, $body = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->updateBroadcastRequest($id, $social_networks, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBroadcastAsync
     *
     * Updates the Broadcast objects fields if it's not null. The updated fields are as follows: name, description, userName, password, IP address, streamUrl of the broadcast. It also updates the social endpoints
     *
     * @param  string $id Broadcast id (required)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs (required)
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object with the updates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBroadcastAsync($id, $social_networks, $body = null)
    {
        return $this->updateBroadcastAsyncWithHttpInfo($id, $social_networks, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBroadcastAsyncWithHttpInfo
     *
     * Updates the Broadcast objects fields if it's not null. The updated fields are as follows: name, description, userName, password, IP address, streamUrl of the broadcast. It also updates the social endpoints
     *
     * @param  string $id Broadcast id (required)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs (required)
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object with the updates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBroadcastAsyncWithHttpInfo($id, $social_networks, $body = null)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->updateBroadcastRequest($id, $social_networks, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBroadcast'
     *
     * @param  string $id Broadcast id (required)
     * @param  string $social_networks Comma separated social network IDs, they must in comma separated and IDs must match with the defined IDs (required)
     * @param  \Thecodebunny\StreamingEngine\Model\Broadcast $body Broadcast object with the updates (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBroadcastRequest($id, $social_networks, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateBroadcast'
            );
        }
        // verify the required parameter 'social_networks' is set
        if ($social_networks === null || (is_array($social_networks) && count($social_networks) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $social_networks when calling updateBroadcast'
            );
        }

        $resourcePath = '/v2/broadcasts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($social_networks !== null) {
            $queryParams['socialNetworks'] = ObjectSerializer::toQueryValue($social_networks);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateTokenV2
     *
     * Perform validation of token for requested stream. If validated, success field is true, not validated success field false
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Token $body Token to be validated (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Thecodebunny\StreamingEngine\Model\Result
     */
    public function validateTokenV2($body)
    {
        list($response) = $this->validateTokenV2WithHttpInfo($body);
        return $response;
    }

    /**
     * Operation validateTokenV2WithHttpInfo
     *
     * Perform validation of token for requested stream. If validated, success field is true, not validated success field false
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Token $body Token to be validated (required)
     *
     * @throws \Thecodebunny\StreamingEngine\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Thecodebunny\StreamingEngine\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateTokenV2WithHttpInfo($body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->validateTokenV2Request($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Thecodebunny\StreamingEngine\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateTokenV2Async
     *
     * Perform validation of token for requested stream. If validated, success field is true, not validated success field false
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Token $body Token to be validated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateTokenV2Async($body)
    {
        return $this->validateTokenV2AsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateTokenV2AsyncWithHttpInfo
     *
     * Perform validation of token for requested stream. If validated, success field is true, not validated success field false
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Token $body Token to be validated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateTokenV2AsyncWithHttpInfo($body)
    {
        $returnType = '\Thecodebunny\StreamingEngine\Model\Result';
        $request = $this->validateTokenV2Request($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateTokenV2'
     *
     * @param  \Thecodebunny\StreamingEngine\Model\Token $body Token to be validated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function validateTokenV2Request($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling validateTokenV2'
            );
        }

        $resourcePath = '/v2/broadcasts/validate-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
