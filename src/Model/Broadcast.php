<?php
/**
 * Broadcast
 *
 * PHP version 5
 *
 * @category Class
 * @package  Thecodebunny\StreamingEngine
 * @author   TCB Codegen team
 * @link     https://github.com/tcb-api/tcb-codegen
 */

/**
 * Streaming Server REST API Reference
 *
 * Streaming Server REST API Reference
 *
 * OpenAPI spec version: V2.0
 * Contact: contact@thecodebunny.com
 * Generated by: https://github.com/tcb-api/tcb-codegen.git
 * TCB Codegen version: 2.4.13
 */

/**
 * NOTE: This class is auto generated by the tcb code generator program.
 * https://github.com/tcb-api/tcb-codegen
 * Do not edit the class manually.
 */

namespace Thecodebunny\StreamingEngine\Model;

use \ArrayAccess;
use \Thecodebunny\StreamingEngine\ObjectSerializer;

/**
 * Broadcast Class Doc Comment
 *
 * @category Class
 * @description The basic broadcast class
 * @package  Thecodebunny\StreamingEngine
 * @author   TCB Codegen team
 * @link     https://github.com/tcb-api/tcb-codegen
 */
class Broadcast implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $tcbModelName = 'Broadcast';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $tcbTypes = [
        'stream_id' => 'string',
        'status' => 'string',
        'type' => 'string',
        'name' => 'string',
        'description' => 'string',
        'publish' => 'bool',
        'date' => 'int',
        'planned_start_date' => 'int',
        'duration' => 'int',
        'end_point_list' => '\Thecodebunny\StreamingEngine\Model\Endpoint[]',
        'public_stream' => 'bool',
        'is360' => 'bool',
        'listener_hook_url' => 'string',
        'category' => 'string',
        'ip_addr' => 'string',
        'username' => 'string',
        'password' => 'string',
        'quality' => 'string',
        'speed' => 'double',
        'stream_url' => 'string',
        'origin_adress' => 'string',
        'mp4_enabled' => 'int',
        'expire_duration_ms' => 'int',
        'rtmp_url' => 'string',
        'zombi' => 'bool',
        'pending_packet_size' => 'int',
        'hls_viewer_count' => 'int',
        'web_rtc_viewer_count' => 'int',
        'rtmp_viewer_count' => 'int',
        'start_time' => 'int',
        'received_bytes' => 'int',
        'bitrate' => 'int',
        'user_agent' => 'string',
        'latitude' => 'string',
        'longitude' => 'string',
        'altitude' => 'string',
        'main_track_stream_id' => 'string',
        'sub_track_stream_ids' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $tcbFormats = [
        'stream_id' => null,
        'status' => null,
        'type' => null,
        'name' => null,
        'description' => null,
        'publish' => null,
        'date' => 'int64',
        'planned_start_date' => 'int64',
        'duration' => 'int64',
        'end_point_list' => null,
        'public_stream' => null,
        'is360' => null,
        'listener_hook_url' => null,
        'category' => null,
        'ip_addr' => null,
        'username' => null,
        'password' => null,
        'quality' => null,
        'speed' => 'double',
        'stream_url' => null,
        'origin_adress' => null,
        'mp4_enabled' => 'int32',
        'expire_duration_ms' => 'int32',
        'rtmp_url' => null,
        'zombi' => null,
        'pending_packet_size' => 'int32',
        'hls_viewer_count' => 'int32',
        'web_rtc_viewer_count' => 'int32',
        'rtmp_viewer_count' => 'int32',
        'start_time' => 'int64',
        'received_bytes' => 'int64',
        'bitrate' => 'int64',
        'user_agent' => null,
        'latitude' => null,
        'longitude' => null,
        'altitude' => null,
        'main_track_stream_id' => null,
        'sub_track_stream_ids' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function tcbTypes()
    {
        return self::$tcbTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function tcbFormats()
    {
        return self::$tcbFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'stream_id' => 'streamId',
        'status' => 'status',
        'type' => 'type',
        'name' => 'name',
        'description' => 'description',
        'publish' => 'publish',
        'date' => 'date',
        'planned_start_date' => 'plannedStartDate',
        'duration' => 'duration',
        'end_point_list' => 'endPointList',
        'public_stream' => 'publicStream',
        'is360' => 'is360',
        'listener_hook_url' => 'listenerHookURL',
        'category' => 'category',
        'ip_addr' => 'ipAddr',
        'username' => 'username',
        'password' => 'password',
        'quality' => 'quality',
        'speed' => 'speed',
        'stream_url' => 'streamUrl',
        'origin_adress' => 'originAdress',
        'mp4_enabled' => 'mp4Enabled',
        'expire_duration_ms' => 'expireDurationMS',
        'rtmp_url' => 'rtmpURL',
        'zombi' => 'zombi',
        'pending_packet_size' => 'pendingPacketSize',
        'hls_viewer_count' => 'hlsViewerCount',
        'web_rtc_viewer_count' => 'webRTCViewerCount',
        'rtmp_viewer_count' => 'rtmpViewerCount',
        'start_time' => 'startTime',
        'received_bytes' => 'receivedBytes',
        'bitrate' => 'bitrate',
        'user_agent' => 'userAgent',
        'latitude' => 'latitude',
        'longitude' => 'longitude',
        'altitude' => 'altitude',
        'main_track_stream_id' => 'mainTrackStreamId',
        'sub_track_stream_ids' => 'subTrackStreamIds'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'stream_id' => 'setStreamId',
        'status' => 'setStatus',
        'type' => 'setType',
        'name' => 'setName',
        'description' => 'setDescription',
        'publish' => 'setPublish',
        'date' => 'setDate',
        'planned_start_date' => 'setPlannedStartDate',
        'duration' => 'setDuration',
        'end_point_list' => 'setEndPointList',
        'public_stream' => 'setPublicStream',
        'is360' => 'setIs360',
        'listener_hook_url' => 'setListenerHookUrl',
        'category' => 'setCategory',
        'ip_addr' => 'setIpAddr',
        'username' => 'setUsername',
        'password' => 'setPassword',
        'quality' => 'setQuality',
        'speed' => 'setSpeed',
        'stream_url' => 'setStreamUrl',
        'origin_adress' => 'setOriginAdress',
        'mp4_enabled' => 'setMp4Enabled',
        'expire_duration_ms' => 'setExpireDurationMs',
        'rtmp_url' => 'setRtmpUrl',
        'zombi' => 'setZombi',
        'pending_packet_size' => 'setPendingPacketSize',
        'hls_viewer_count' => 'setHlsViewerCount',
        'web_rtc_viewer_count' => 'setWebRtcViewerCount',
        'rtmp_viewer_count' => 'setRtmpViewerCount',
        'start_time' => 'setStartTime',
        'received_bytes' => 'setReceivedBytes',
        'bitrate' => 'setBitrate',
        'user_agent' => 'setUserAgent',
        'latitude' => 'setLatitude',
        'longitude' => 'setLongitude',
        'altitude' => 'setAltitude',
        'main_track_stream_id' => 'setMainTrackStreamId',
        'sub_track_stream_ids' => 'setSubTrackStreamIds'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'stream_id' => 'getStreamId',
        'status' => 'getStatus',
        'type' => 'getType',
        'name' => 'getName',
        'description' => 'getDescription',
        'publish' => 'getPublish',
        'date' => 'getDate',
        'planned_start_date' => 'getPlannedStartDate',
        'duration' => 'getDuration',
        'end_point_list' => 'getEndPointList',
        'public_stream' => 'getPublicStream',
        'is360' => 'getIs360',
        'listener_hook_url' => 'getListenerHookUrl',
        'category' => 'getCategory',
        'ip_addr' => 'getIpAddr',
        'username' => 'getUsername',
        'password' => 'getPassword',
        'quality' => 'getQuality',
        'speed' => 'getSpeed',
        'stream_url' => 'getStreamUrl',
        'origin_adress' => 'getOriginAdress',
        'mp4_enabled' => 'getMp4Enabled',
        'expire_duration_ms' => 'getExpireDurationMs',
        'rtmp_url' => 'getRtmpUrl',
        'zombi' => 'getZombi',
        'pending_packet_size' => 'getPendingPacketSize',
        'hls_viewer_count' => 'getHlsViewerCount',
        'web_rtc_viewer_count' => 'getWebRtcViewerCount',
        'rtmp_viewer_count' => 'getRtmpViewerCount',
        'start_time' => 'getStartTime',
        'received_bytes' => 'getReceivedBytes',
        'bitrate' => 'getBitrate',
        'user_agent' => 'getUserAgent',
        'latitude' => 'getLatitude',
        'longitude' => 'getLongitude',
        'altitude' => 'getAltitude',
        'main_track_stream_id' => 'getMainTrackStreamId',
        'sub_track_stream_ids' => 'getSubTrackStreamIds'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$tcbModelName;
    }

    const STATUS_FINISHED = 'finished';
    const STATUS_BROADCASTING = 'broadcasting';
    const STATUS_CREATED = 'created';
    const TYPE_LIVE_STREAM = 'liveStream';
    const TYPE_IP_CAMERA = 'ipCamera';
    const TYPE_STREAM_SOURCE = 'streamSource';
    const TYPE_VO_D = 'VoD';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_FINISHED,
            self::STATUS_BROADCASTING,
            self::STATUS_CREATED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_LIVE_STREAM,
            self::TYPE_IP_CAMERA,
            self::TYPE_STREAM_SOURCE,
            self::TYPE_VO_D,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['stream_id'] = isset($data['stream_id']) ? $data['stream_id'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['publish'] = isset($data['publish']) ? $data['publish'] : null;
        $this->container['date'] = isset($data['date']) ? $data['date'] : null;
        $this->container['planned_start_date'] = isset($data['planned_start_date']) ? $data['planned_start_date'] : null;
        $this->container['duration'] = isset($data['duration']) ? $data['duration'] : null;
        $this->container['end_point_list'] = isset($data['end_point_list']) ? $data['end_point_list'] : null;
        $this->container['public_stream'] = isset($data['public_stream']) ? $data['public_stream'] : null;
        $this->container['is360'] = isset($data['is360']) ? $data['is360'] : null;
        $this->container['listener_hook_url'] = isset($data['listener_hook_url']) ? $data['listener_hook_url'] : null;
        $this->container['category'] = isset($data['category']) ? $data['category'] : null;
        $this->container['ip_addr'] = isset($data['ip_addr']) ? $data['ip_addr'] : null;
        $this->container['username'] = isset($data['username']) ? $data['username'] : null;
        $this->container['password'] = isset($data['password']) ? $data['password'] : null;
        $this->container['quality'] = isset($data['quality']) ? $data['quality'] : null;
        $this->container['speed'] = isset($data['speed']) ? $data['speed'] : null;
        $this->container['stream_url'] = isset($data['stream_url']) ? $data['stream_url'] : null;
        $this->container['origin_adress'] = isset($data['origin_adress']) ? $data['origin_adress'] : null;
        $this->container['mp4_enabled'] = isset($data['mp4_enabled']) ? $data['mp4_enabled'] : null;
        $this->container['expire_duration_ms'] = isset($data['expire_duration_ms']) ? $data['expire_duration_ms'] : null;
        $this->container['rtmp_url'] = isset($data['rtmp_url']) ? $data['rtmp_url'] : null;
        $this->container['zombi'] = isset($data['zombi']) ? $data['zombi'] : null;
        $this->container['pending_packet_size'] = isset($data['pending_packet_size']) ? $data['pending_packet_size'] : null;
        $this->container['hls_viewer_count'] = isset($data['hls_viewer_count']) ? $data['hls_viewer_count'] : null;
        $this->container['web_rtc_viewer_count'] = isset($data['web_rtc_viewer_count']) ? $data['web_rtc_viewer_count'] : null;
        $this->container['rtmp_viewer_count'] = isset($data['rtmp_viewer_count']) ? $data['rtmp_viewer_count'] : null;
        $this->container['start_time'] = isset($data['start_time']) ? $data['start_time'] : null;
        $this->container['received_bytes'] = isset($data['received_bytes']) ? $data['received_bytes'] : null;
        $this->container['bitrate'] = isset($data['bitrate']) ? $data['bitrate'] : null;
        $this->container['user_agent'] = isset($data['user_agent']) ? $data['user_agent'] : null;
        $this->container['latitude'] = isset($data['latitude']) ? $data['latitude'] : null;
        $this->container['longitude'] = isset($data['longitude']) ? $data['longitude'] : null;
        $this->container['altitude'] = isset($data['altitude']) ? $data['altitude'] : null;
        $this->container['main_track_stream_id'] = isset($data['main_track_stream_id']) ? $data['main_track_stream_id'] : null;
        $this->container['sub_track_stream_ids'] = isset($data['sub_track_stream_ids']) ? $data['sub_track_stream_ids'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets stream_id
     *
     * @return string
     */
    public function getStreamId()
    {
        return $this->container['stream_id'];
    }

    /**
     * Sets stream_id
     *
     * @param string $stream_id the id of the stream
     *
     * @return $this
     */
    public function setStreamId($stream_id)
    {
        $this->container['stream_id'] = $stream_id;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status the status of the stream
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type the type of the stream
     *
     * @return $this
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name the name of the stream
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description the description of the stream
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets publish
     *
     * @return bool
     */
    public function getPublish()
    {
        return $this->container['publish'];
    }

    /**
     * Sets publish
     *
     * @param bool $publish it is a video filter for the service, this value is controlled by the user, default value is true in the db
     *
     * @return $this
     */
    public function setPublish($publish)
    {
        $this->container['publish'] = $publish;

        return $this;
    }

    /**
     * Gets date
     *
     * @return int
     */
    public function getDate()
    {
        return $this->container['date'];
    }

    /**
     * Sets date
     *
     * @param int $date the date when record is created in milliseconds
     *
     * @return $this
     */
    public function setDate($date)
    {
        $this->container['date'] = $date;

        return $this;
    }

    /**
     * Gets planned_start_date
     *
     * @return int
     */
    public function getPlannedStartDate()
    {
        return $this->container['planned_start_date'];
    }

    /**
     * Sets planned_start_date
     *
     * @param int $planned_start_date the planned start date
     *
     * @return $this
     */
    public function setPlannedStartDate($planned_start_date)
    {
        $this->container['planned_start_date'] = $planned_start_date;

        return $this;
    }

    /**
     * Gets duration
     *
     * @return int
     */
    public function getDuration()
    {
        return $this->container['duration'];
    }

    /**
     * Sets duration
     *
     * @param int $duration the duration of the stream in milliseconds
     *
     * @return $this
     */
    public function setDuration($duration)
    {
        $this->container['duration'] = $duration;

        return $this;
    }

    /**
     * Gets end_point_list
     *
     * @return \Thecodebunny\StreamingEngine\Model\Endpoint[]
     */
    public function getEndPointList()
    {
        return $this->container['end_point_list'];
    }

    /**
     * Sets end_point_list
     *
     * @param \Thecodebunny\StreamingEngine\Model\Endpoint[] $end_point_list the list of endpoints such as Facebook, Twitter or custom RTMP endpoints
     *
     * @return $this
     */
    public function setEndPointList($end_point_list)
    {
        $this->container['end_point_list'] = $end_point_list;

        return $this;
    }

    /**
     * Gets public_stream
     *
     * @return bool
     */
    public function getPublicStream()
    {
        return $this->container['public_stream'];
    }

    /**
     * Sets public_stream
     *
     * @param bool $public_stream the identifier of whether stream is public or not
     *
     * @return $this
     */
    public function setPublicStream($public_stream)
    {
        $this->container['public_stream'] = $public_stream;

        return $this;
    }

    /**
     * Gets is360
     *
     * @return bool
     */
    public function getIs360()
    {
        return $this->container['is360'];
    }

    /**
     * Sets is360
     *
     * @param bool $is360 the identifier of whether stream is 360 or not
     *
     * @return $this
     */
    public function setIs360($is360)
    {
        $this->container['is360'] = $is360;

        return $this;
    }

    /**
     * Gets listener_hook_url
     *
     * @return string
     */
    public function getListenerHookUrl()
    {
        return $this->container['listener_hook_url'];
    }

    /**
     * Sets listener_hook_url
     *
     * @param string $listener_hook_url the url that will be notified when stream is published, ended and muxing finished
     *
     * @return $this
     */
    public function setListenerHookUrl($listener_hook_url)
    {
        $this->container['listener_hook_url'] = $listener_hook_url;

        return $this;
    }

    /**
     * Gets category
     *
     * @return string
     */
    public function getCategory()
    {
        return $this->container['category'];
    }

    /**
     * Sets category
     *
     * @param string $category the category of the stream
     *
     * @return $this
     */
    public function setCategory($category)
    {
        $this->container['category'] = $category;

        return $this;
    }

    /**
     * Gets ip_addr
     *
     * @return string
     */
    public function getIpAddr()
    {
        return $this->container['ip_addr'];
    }

    /**
     * Sets ip_addr
     *
     * @param string $ip_addr the IP Address of the IP Cameraor publisher
     *
     * @return $this
     */
    public function setIpAddr($ip_addr)
    {
        $this->container['ip_addr'] = $ip_addr;

        return $this;
    }

    /**
     * Gets username
     *
     * @return string
     */
    public function getUsername()
    {
        return $this->container['username'];
    }

    /**
     * Sets username
     *
     * @param string $username the user name of the IP Camera
     *
     * @return $this
     */
    public function setUsername($username)
    {
        $this->container['username'] = $username;

        return $this;
    }

    /**
     * Gets password
     *
     * @return string
     */
    public function getPassword()
    {
        return $this->container['password'];
    }

    /**
     * Sets password
     *
     * @param string $password the password of the IP Camera
     *
     * @return $this
     */
    public function setPassword($password)
    {
        $this->container['password'] = $password;

        return $this;
    }

    /**
     * Gets quality
     *
     * @return string
     */
    public function getQuality()
    {
        return $this->container['quality'];
    }

    /**
     * Sets quality
     *
     * @param string $quality the quality of the incoming stream during publishing
     *
     * @return $this
     */
    public function setQuality($quality)
    {
        $this->container['quality'] = $quality;

        return $this;
    }

    /**
     * Gets speed
     *
     * @return double
     */
    public function getSpeed()
    {
        return $this->container['speed'];
    }

    /**
     * Sets speed
     *
     * @param double $speed the speed of the incoming stream, for better quality and performance it should be around 1.00
     *
     * @return $this
     */
    public function setSpeed($speed)
    {
        $this->container['speed'] = $speed;

        return $this;
    }

    /**
     * Gets stream_url
     *
     * @return string
     */
    public function getStreamUrl()
    {
        return $this->container['stream_url'];
    }

    /**
     * Sets stream_url
     *
     * @param string $stream_url the stream URL for fetching stream, especially should be defined for IP Cameras or Cloud streams
     *
     * @return $this
     */
    public function setStreamUrl($stream_url)
    {
        $this->container['stream_url'] = $stream_url;

        return $this;
    }

    /**
     * Gets origin_adress
     *
     * @return string
     */
    public function getOriginAdress()
    {
        return $this->container['origin_adress'];
    }

    /**
     * Sets origin_adress
     *
     * @param string $origin_adress the origin address server broadcasting
     *
     * @return $this
     */
    public function setOriginAdress($origin_adress)
    {
        $this->container['origin_adress'] = $origin_adress;

        return $this;
    }

    /**
     * Gets mp4_enabled
     *
     * @return int
     */
    public function getMp4Enabled()
    {
        return $this->container['mp4_enabled'];
    }

    /**
     * Sets mp4_enabled
     *
     * @param int $mp4_enabled MP4 muxing whether enabled or not for the stream, 1 means enabled, -1 means disabled, 0 means no settings for the stream
     *
     * @return $this
     */
    public function setMp4Enabled($mp4_enabled)
    {
        $this->container['mp4_enabled'] = $mp4_enabled;

        return $this;
    }

    /**
     * Gets expire_duration_ms
     *
     * @return int
     */
    public function getExpireDurationMs()
    {
        return $this->container['expire_duration_ms'];
    }

    /**
     * Sets expire_duration_ms
     *
     * @param int $expire_duration_ms the expire time in milliseconds For instance if this value is 10000 then broadcast should be started in 10 seconds after it is created.If expire duration is 0, then stream will never expire
     *
     * @return $this
     */
    public function setExpireDurationMs($expire_duration_ms)
    {
        $this->container['expire_duration_ms'] = $expire_duration_ms;

        return $this;
    }

    /**
     * Gets rtmp_url
     *
     * @return string
     */
    public function getRtmpUrl()
    {
        return $this->container['rtmp_url'];
    }

    /**
     * Sets rtmp_url
     *
     * @param string $rtmp_url the RTMP URL where to publish live stream to
     *
     * @return $this
     */
    public function setRtmpUrl($rtmp_url)
    {
        $this->container['rtmp_url'] = $rtmp_url;

        return $this;
    }

    /**
     * Gets zombi
     *
     * @return bool
     */
    public function getZombi()
    {
        return $this->container['zombi'];
    }

    /**
     * Sets zombi
     *
     * @param bool $zombi is true, if a broadcast that is not added to data store through rest service or management console It is false by default
     *
     * @return $this
     */
    public function setZombi($zombi)
    {
        $this->container['zombi'] = $zombi;

        return $this;
    }

    /**
     * Gets pending_packet_size
     *
     * @return int
     */
    public function getPendingPacketSize()
    {
        return $this->container['pending_packet_size'];
    }

    /**
     * Sets pending_packet_size
     *
     * @param int $pending_packet_size the number of audio and video packets that is being pending to be encoded in the queue
     *
     * @return $this
     */
    public function setPendingPacketSize($pending_packet_size)
    {
        $this->container['pending_packet_size'] = $pending_packet_size;

        return $this;
    }

    /**
     * Gets hls_viewer_count
     *
     * @return int
     */
    public function getHlsViewerCount()
    {
        return $this->container['hls_viewer_count'];
    }

    /**
     * Sets hls_viewer_count
     *
     * @param int $hls_viewer_count the number of HLS viewers of the stream
     *
     * @return $this
     */
    public function setHlsViewerCount($hls_viewer_count)
    {
        $this->container['hls_viewer_count'] = $hls_viewer_count;

        return $this;
    }

    /**
     * Gets web_rtc_viewer_count
     *
     * @return int
     */
    public function getWebRtcViewerCount()
    {
        return $this->container['web_rtc_viewer_count'];
    }

    /**
     * Sets web_rtc_viewer_count
     *
     * @param int $web_rtc_viewer_count the number of WebRTC viewers of the stream
     *
     * @return $this
     */
    public function setWebRtcViewerCount($web_rtc_viewer_count)
    {
        $this->container['web_rtc_viewer_count'] = $web_rtc_viewer_count;

        return $this;
    }

    /**
     * Gets rtmp_viewer_count
     *
     * @return int
     */
    public function getRtmpViewerCount()
    {
        return $this->container['rtmp_viewer_count'];
    }

    /**
     * Sets rtmp_viewer_count
     *
     * @param int $rtmp_viewer_count the number of RTMP viewers of the stream
     *
     * @return $this
     */
    public function setRtmpViewerCount($rtmp_viewer_count)
    {
        $this->container['rtmp_viewer_count'] = $rtmp_viewer_count;

        return $this;
    }

    /**
     * Gets start_time
     *
     * @return int
     */
    public function getStartTime()
    {
        return $this->container['start_time'];
    }

    /**
     * Sets start_time
     *
     * @param int $start_time the publishing start time of the stream
     *
     * @return $this
     */
    public function setStartTime($start_time)
    {
        $this->container['start_time'] = $start_time;

        return $this;
    }

    /**
     * Gets received_bytes
     *
     * @return int
     */
    public function getReceivedBytes()
    {
        return $this->container['received_bytes'];
    }

    /**
     * Sets received_bytes
     *
     * @param int $received_bytes the received bytes until now
     *
     * @return $this
     */
    public function setReceivedBytes($received_bytes)
    {
        $this->container['received_bytes'] = $received_bytes;

        return $this;
    }

    /**
     * Gets bitrate
     *
     * @return int
     */
    public function getBitrate()
    {
        return $this->container['bitrate'];
    }

    /**
     * Sets bitrate
     *
     * @param int $bitrate the received bytes / duration
     *
     * @return $this
     */
    public function setBitrate($bitrate)
    {
        $this->container['bitrate'] = $bitrate;

        return $this;
    }

    /**
     * Gets user_agent
     *
     * @return string
     */
    public function getUserAgent()
    {
        return $this->container['user_agent'];
    }

    /**
     * Sets user_agent
     *
     * @param string $user_agent User - Agent
     *
     * @return $this
     */
    public function setUserAgent($user_agent)
    {
        $this->container['user_agent'] = $user_agent;

        return $this;
    }

    /**
     * Gets latitude
     *
     * @return string
     */
    public function getLatitude()
    {
        return $this->container['latitude'];
    }

    /**
     * Sets latitude
     *
     * @param string $latitude latitude of the broadcasting location
     *
     * @return $this
     */
    public function setLatitude($latitude)
    {
        $this->container['latitude'] = $latitude;

        return $this;
    }

    /**
     * Gets longitude
     *
     * @return string
     */
    public function getLongitude()
    {
        return $this->container['longitude'];
    }

    /**
     * Sets longitude
     *
     * @param string $longitude longitude of the broadcasting location
     *
     * @return $this
     */
    public function setLongitude($longitude)
    {
        $this->container['longitude'] = $longitude;

        return $this;
    }

    /**
     * Gets altitude
     *
     * @return string
     */
    public function getAltitude()
    {
        return $this->container['altitude'];
    }

    /**
     * Sets altitude
     *
     * @param string $altitude altitude of the broadcasting location
     *
     * @return $this
     */
    public function setAltitude($altitude)
    {
        $this->container['altitude'] = $altitude;

        return $this;
    }

    /**
     * Gets main_track_stream_id
     *
     * @return string
     */
    public function getMainTrackStreamId()
    {
        return $this->container['main_track_stream_id'];
    }

    /**
     * Sets main_track_stream_id
     *
     * @param string $main_track_stream_id If this broadcast is a track of a WebRTC stream. This variable is Id of that stream.
     *
     * @return $this
     */
    public function setMainTrackStreamId($main_track_stream_id)
    {
        $this->container['main_track_stream_id'] = $main_track_stream_id;

        return $this;
    }

    /**
     * Gets sub_track_stream_ids
     *
     * @return string[]
     */
    public function getSubTrackStreamIds()
    {
        return $this->container['sub_track_stream_ids'];
    }

    /**
     * Sets sub_track_stream_ids
     *
     * @param string[] $sub_track_stream_ids If this broadcast is main track. This variable hold sub track ids.
     *
     * @return $this
     */
    public function setSubTrackStreamIds($sub_track_stream_ids)
    {
        $this->container['sub_track_stream_ids'] = $sub_track_stream_ids;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


